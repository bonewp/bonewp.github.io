<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[卷积的物理意义]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>今天仿matlab的时候用到卷积函数<code>conv(u, v)</code>，然后看到参考文档中的描述是  </p>
<blockquote>
<p>Convolution and polynomial multiplication</p>
</blockquote>
<p>突然就觉得很奇怪，为什么会等价于多项式乘法呢。<br>然后看了下example吓了一跳，从数学表达式上来看完全就是一样的东西嘛。  </p>
<blockquote>
<p>Create vectors u and v containing the coefficients of the polynomials $x^2+1$ and $2x+7$.<br><code>u = [1 0 1];</code><br><code>v = [2 7];</code><br>Use convolution to multiply the polynomials.<br><code>w = conv(u,v)</code><br>w =   2     7     2     7<br>w contains the polynomial coefficients for $2x&amp;3+7x^2+2x+7$.</p>
</blockquote>
<p>然后就去google卷积，发现了知乎上一个回答挺有趣的，<a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="external">怎样通俗易懂地解释卷积？</a><br>这个回答中的图示没有用教科书中讲的反褶+时移相乘，而是$x[n]$乘以$y[k]$的时移和叠加。回答者的描述是  </p>
<blockquote>
<p>可以看到卷积的重要的物理意义是：一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。<br>通俗的说：<br>在输入信号的每个位置，叠加一个单位响应，就得到了输出信号。</p>
</blockquote>
<p>回想一下信号与系统的知识，可以说这个回答非常符合认知，也能和上面的多项式相乘对应起来。<br>接触了很久的卷积现在才发现有着这么层意思在里面，只能说当年学得太渣…残念…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数字信号的基带传输和载波传输中的几个点]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93%E5%92%8C%E8%BD%BD%E6%B3%A2%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="成型滤波"><a href="#成型滤波" class="headerlink" title="成型滤波"></a>成型滤波</h3><p>升余弦滚降信号：以 $\pi /t$ 为中心，具有奇对称升余弦个月形状过渡带的一类的无串扰波形。其中滚降系数 $\alpha$ 介于0~1之间，$\alpha$=0 时为具有最窄频带的无串扰波形（奈奎斯特带宽），频带利用率最高但实际不可能达到。  </p>
<p>升余弦滚降信号占用带宽 $B=(1+\alpha )f_s/2$，$\alpha$ 越大，传输频带越大，而波形振荡起伏越小，抽样时刻误差越小。通常取 $\alpha \geq 0.2$。    </p>
<a id="more"></a>
<h3 id="匹配滤波器"><a href="#匹配滤波器" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h3><p>$H(f)=KS^*(f)e^{(-j2\pi fT)}$<br>输出信噪比最大的滤波器，其传递函数与信号频谱的复共轭成正比，称为匹配滤波器。  </p>
<p>$h(t)=KS(T-t)$<br>匹配滤波器的冲击响应是输入信号$S(t)$的镜像及平移。  </p>
<p>匹配滤波器的输出信号波形与输入信号的自相关函数成比例。  </p>
<h3 id="MPSK"><a href="#MPSK" class="headerlink" title="MPSK"></a>MPSK</h3><p>多进制相移键控，载波相位有M种取值。  </p>
<p>已调信号时域表达式可简写为，$S_{MPSK}(t) = I(t)\cos(\omega_c t) - Q(t)\sin(\omega_c t)$，所以可用正交调制的方法产生。这里<br>同相分量 $I(t) = \Sigma a_n rect(t-nT_s)$<br>正交分量 $Q(t) = \Sigma b_n rect(t-nT_s)$<br>其中rect矩形函数，即为矩形包络，可使用成型滤波的升余弦滚降信号作为包络吧？<br>而$a_n=Acos\phi(n)$, $b_n=Asin\phi(n)$。  </p>
<p>8PSK相干调制时，每3bit产生一3位码组$b_1 b_2 b_3$，在其控制下同相路和正交路分别产生两个四电平基带信号I(t)和Q(t)，$b_1$决定同相路信号极性而$b_2$决定正交路信号极性，$b_3$则确定两路信号的幅度，分别为$cos\pi /3$和$sin\pi /3$，即两路基带信号幅度互相关联，不可独立选取(使合成矢量端点落在圆上)。<br>还有相位选择法调制(适用于高载频)和脉冲插入法调制。其中选相法，我觉得在DDS中通过符号对应相位偏移就可以简单实现。  </p>
<p>可用两正交载波信号实现相干解调，区别在于多进制调制时为多电平判决，如QPSK为二电平判决而8PSK为四电平判决。</p>
<h3 id="MQAM"><a href="#MQAM" class="headerlink" title="MQAM"></a>MQAM</h3><p>正交幅度调制(Quadruate Amplitude Modelation)，为幅度与相位相结合的调制方式，在星座图上区别于MPSK的圆上均匀分布，MQAM在圆内按矩形或十字形等距离分布，矢量端点距离更大，抗干扰能力更强。  </p>
<p>在两正交载波上进行幅度调制实现，区别于MPSK，MQAM的同相和正交两路基带信号的电平相互独立。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雷达波形与信号]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E9%9B%B7%E8%BE%BE%E6%B3%A2%E5%BD%A2%E4%B8%8E%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h3 id="雷达的分辨率"><a href="#雷达的分辨率" class="headerlink" title="雷达的分辨率"></a>雷达的分辨率</h3><p>雷达波形$u(t)$的自相关函数主瓣宽度越窄，其距离分辨能力越强。即若要时间（距离）分辨率好，应选择这样的信号，即它通过匹配滤波器后应该输出很窄的主瓣波峰。这样的信号或是具有很短持续时间的脉冲，或是具有很宽频谱的宽带波形。  </p>
<p>瑞利时间分辨率：$\delta_t = 1/B$，或等效地，瑞利距离分辨率：$\delta_r = c/{2B}$。  </p>
<p>多普勒频率分辨率:$\delta_{fd} = 1/T$，或对目标径向速度分辨率:$\delta_v = \lambda / {2T}$。  </p>
<p>总结：</p>
<ol>
<li><strong>雷达的距离/时间分辨率由雷达发射信号的带宽决定。</strong> 该带宽可以是瞬时的(如极窄的脉冲)，也可以是合成的(通过时间换取，如脉冲持续时间长的线性调频波)。在实际应用中，该宽带信号可是窄脉冲波形、线性调频波形、频率步进波形、随机或伪随机噪声波形及其他任何宽带调制信号。  </li>
<li><strong>雷达的速度/多普勒分辨率由信号的持续时间决定。</strong> 持续时间越长，分辨率越高。可通过发射持续时间长的脉冲或通过多个脉冲的相参积累等实现。  </li>
</ol>
<a id="more"></a>
<h3 id="线性调频脉冲LFM"><a href="#线性调频脉冲LFM" class="headerlink" title="线性调频脉冲LFM"></a>线性调频脉冲LFM</h3><p>Linear Frequency Modulation，LFM。对雷达波形进行调频得到宽带信号，分为上变频和下变频。  </p>
<p>该体制采用宽脉冲发射以提高发射的平均功率，保证足够大的作用距离；而接收时采用相应的脉冲压缩算法获得窄脉冲，以提高距离分辨率，较好的解决雷达作用距离与距离分辨率之间的矛盾。</p>
<img src="/2017/03/28/雷达波形与信号/LFM信号示意图.jpg" alt="LFM信号示意图.jpg" title="">  
<p>设线性调频信号为$s(t) = 1/\sqrt{t_p} rect(t/t_p)e^{j(\omega_c t+\pi \gamma t^2)}$<br>其中$\omega_c$为中心频率，$t_p$为脉冲宽度，$\gamma$为线性调频斜率，$B=\gamma t_p$<br>包络调制函数为$u(t) = 1/\sqrt{t_p} rect(t/t_p)e^{(j\pi \gamma t^2)}$<br>随时间变化的频率函数为$f(t)=1/{2\pi}d/{dt} (\omega_c t + \pi \gamma t^2) = \omega_c/{2\pi}+\gamma t$  </p>
<p>Matlab仿真代码示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">%%demo of chirp signal</div><div class="line">T=20e-6;                          %pulse duration us</div><div class="line">B=50e6;                           %chirp frequency modulation bandwidth MHz</div><div class="line">K=B/T;                            %chirp slope</div><div class="line">Fs=4*B;Ts=1/Fs;                   %sampling frequency and sample spacing</div><div class="line">N=T/Ts;</div><div class="line">fc=0;</div><div class="line">t=linspace(-T/2,T/2,N);</div><div class="line">St=exp(1i*pi*K*t.^2);                 %generate chirp signal</div><div class="line">St=St.*exp(1i*2*pi*fc*t);</div><div class="line">subplot(211)</div><div class="line">plot(t*1e6,real(St));</div><div class="line">xlabel(&apos;Time in u sec&apos;);</div><div class="line">title(&apos;Real part of chirp signal&apos;);</div><div class="line">grid on;</div><div class="line">subplot(212)</div><div class="line">freq=linspace(-Fs/2,Fs/2,N);</div><div class="line">plot(freq*1e-6,fftshift(abs(fft(St))));</div><div class="line">xlabel(&apos;Frequency in MHz&apos;);</div><div class="line">title(&apos;Magnitude spectrum of chirp signal&apos;);</div><div class="line">grid on;</div></pre></td></tr></table></figure></p>
<p>结果如下<br><img src="/2017/03/28/雷达波形与信号/lfm信号仿真结果.png" alt="lfm信号仿真结果.png" title="">  </p>
<h3 id="脉冲压缩"><a href="#脉冲压缩" class="headerlink" title="脉冲压缩"></a>脉冲压缩</h3><p>线性调频斜率为$\gamma$、脉宽为$t_p$的脉冲，通过匹配滤波器后，时间分辨率为$1/\gamma t_p$。对于雷达接收机而言，相当于输入脉冲的宽度为$t_p$，输出脉冲宽的为$1/\gamma t_p = 1/B$，即输出与输入脉冲宽度之比为$1/\gamma t_p^2$。<br>在LFM雷达中，$\gamma t_p^2$通常称为时宽带宽积，且有$\gamma t_p^2 \gg 1$。<br>可见，接收机（匹配滤波器）的输出脉冲宽度在时间上被“压缩”，称之为脉冲压缩(Pulse compression)。<br>也就是说，为了获得线性调频信号的大带宽所对应的高级了分辨能力，必须对接收到的LFM宽脉冲回波进行压缩滤波处理（匹配滤波），使其变为窄脉冲。   </p>
<p>实现上，数字方法有非递归滤波器（时域卷积），正-反DFT（频域分析），后者占用内存少、运算量小、速度快，更长用。  </p>
<p>为了抑制旁瓣，减少虚警，常用加权处理。即将匹配滤波器的频率响应乘上某些适当的“窗函数”，在时域中相当于一系列加权函数组成的滤波器和匹配滤波器级联。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cadence使用及画板技巧相关]]></title>
      <url>http://bonewp.github.io.git/2017/03/02/Cadence%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%94%BB%E6%9D%BF%E6%8A%80%E5%B7%A7%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>在课题组这儿画了好几块PCB了，感觉使用Candence画板这活完全就是经验性的工作。学习曲线陡峭，简直就是个阶跃函数，掌握了基础之后就是不断在实际操作中熟练技巧(为什么你这么熟练啊…)。画原理图的时候如果没有以前的参考还会相对复杂一点，要对照datasheet按照要求来连接逻辑关系，布PCB简直就是堆工作量了，经常陷入长时间布线停不下来，总想多做一些早点搞完，但是实际上已经累得头晕脑胀的毫无效率了(珍爱生命远离画板…)。<br>虽然这么说但是过程中需要注意的地方也挺多的，这里把自己以前学习的小记和操作过程的思考记录下来，以后操作前先复习一下以免多次无意义的工作(没错 就是经常删了重布 删了重布)。  </p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Cadence提供了两个集成的、从前端到后端的设计结局方案：Concept-HDL到Allegro；Capture到Allegro。<br>Capture CIS区别于Capture的地方在于CIS——Component Information System，该模块可对元器件和库实施高效管理，还可通过Internet Component Assistant查阅添加元器件。（不过我基本上没用过，都是自己保存的元件库，这个还需注意吧）<br>设计总体思路：</p>
<ol>
<li>原理图：根据框图，确定元器件，若库里无相应器件，需自己画器件模型；再连接元器件之间的端口。首先确定各个模块（每一个文件夹就对应一个模块Schematic Design—Schematic Folder—Schematic Page），在模块内各page连线，再在TOP层将各个模块连接起来。</li>
<li>PCB：根据原理图确定下来的连接关系，对元器件进行具体的布局布线。首先确定板卡的尺寸、固定孔，然后布局（根据具体需求和指导原则），接着布线，最后检查其合理性，对不足的地方修改<del>或者推翻重来</del>。   </li>
</ol>
<img src="/2017/03/02/Cadence使用及画板技巧相关/制板总体设计思路.png" alt="制板总体设计思路.png" title="">  
<h3 id="原理图设计"><a href="#原理图设计" class="headerlink" title="原理图设计"></a>原理图设计</h3><h4 id="元件库制作"><a href="#元件库制作" class="headerlink" title="元件库制作　"></a>元件库制作　</h4><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>如果在参考项目中有需要修改的package，点击该元器件—Edit Part—View Package—save as选择自己的元件库保存。  </li>
<li>如果已有的库里没有元件对应的package，可上官网找CAD文件用官方软件转换为.olb，复制到自己的库中。如果没有，按照管脚定义列表excel自己画。Excel也找不到就自己画吧。</li>
<li>元件会有多种封装，不同封装管脚排列不同，如AD9236有RU-28和CP-32-2两种，分别对应尾缀：BRU和BCP。一般在芯片手册的Order Information或Ordering guide中会包含完整的尾缀和封装对应关系。</li>
<li>元件库名称必须带有表示元件封装的尾缀信息</li>
<li>为实现后续功能，元件库管脚类型(type)必须与实际元件一致<br>常用的管脚类型有：Input, Output,3state,Bidirectional,Open Collector,Open Emitter,Passive,Power等</li>
<li>同一功能有多个管脚，在管脚功能后用不同数字区分(如VCC1,VCC2,GND1,GND2)；数字命名在管脚数较小时按照递增编号；管脚数较多时，可用管脚号（如VCCINT56表示该电源管脚在第56号管脚上）</li>
<li>一般应将管脚按照功能分组摆放</li>
<li>元件管脚必须置于编辑界面的网格(grid)上，否则画原理图时会出现连接错误。</li>
</ul>
<h5 id="制作元件"><a href="#制作元件" class="headerlink" title="制作元件"></a>制作元件</h5><ol>
<li>新建元器件：New library-new part。  </li>
<li>放置引脚：<br>单个引脚Place Pin：其中Number管脚号是非常重要的属性，在PCB设计中，使用Number属性与封装的PinNumber对应，从而建立原理图与PCB的联系。管脚号不光可以是数字，也可以是字母，或字母数字的组合（如某些BGA封装）的管脚号就是字母数字组合。但必须和封装上的管脚号一一对应。<br>多个引脚Place Pin Array—&gt;edit Properties。调整顺序，沿虚线框画矩形外框。<br>在制作FPGA等引脚非常多的元件时，官网会有相关文件方便制作。  </li>
<li>绘制外形：Place-Line or Rectangle。<br>绘制完成后保存至相应的.olb中。<br>另一种方法：new part from spreadsheet，按照datasheet填写表格，其中No. of Section用于表示元件中的第几个part（在multipule-part package情况下）。</li>
</ol>
<h5 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h5><p>Package包装：即库中一个完整的元件，一个Package一般对应PCB中一个元件的封装(Footprint)。<br>Part部件：组成一个完整元件的一个或多个部分。某些元件内部可以按照功能划分为多个部分，每一部分占用元件的一部分管脚。<br>Single Part：元件由唯一的Part组成，大多数简单器件。<br>Multipule Part Package：</p>
<ul>
<li>Homogeneous：内部各Part功能和符号完全相同的元件。每个Part的图形和管脚数和功能都是相同的，但管脚号可以不同。并且可以有部分重复的管脚(如74LS14每个Part上均有VCC和GND两个管脚，不过这些重复的管脚应该都是对应的实际上同一个管脚）。不能使用[New Part From Spreadsheet]制作。</li>
<li>Heterogeneous：元件由多个不同的Part组成。不允许同一个管脚在不同Part中出现（软件不会报错）。  </li>
</ul>
<h4 id="原理图层次"><a href="#原理图层次" class="headerlink" title="原理图层次"></a>原理图层次</h4><p>一个原理图design包含多个模块Block（有一个root schematic即顶层模块），而模块由多个Page组成。<br>Block上的端口(Port)来自于图中各Page上放置的Port符号。如果把Block也看成一个芯片，则Port是这些芯片的管脚。<br>Off Page Connector的作用是连接同一个图中不同页(page)的电路。而Net alias用于连接同一个Page内的电路。<br>电源端口是全局的。  </p>
<h4 id="原理图制作"><a href="#原理图制作" class="headerlink" title="原理图制作"></a>原理图制作</h4><h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h5><p>New-Project。在circuit文件夹下创建sch和pcb分别存放原理图和pcb设计。  </p>
<h5 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h5><p>包括Title Block和Page Size： [Option]-[Design Template]- Title Block-Symbol。<br>New symbol可创建特殊元件，如TitleBlock、电源、地、port、off-page connecter；改变图纸大小Schematic Page Properties-Page Size一般选B及以下。  </p>
<h5 id="创建顶层页面"><a href="#创建顶层页面" class="headerlink" title="创建顶层页面"></a>创建顶层页面</h5><p>Root Design中分别建立Page1: Title、Page2: Topology和Page3: Top三个页，在Topology页中绘制或粘贴电路框图。  </p>
<h5 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h5><p>[Place]–[Part]中添加自己的元件库以。注意“Design Cache”并不是一个真正的库文件，而是当前工程的设计缓冲。  </p>
<h5 id="分模块画子图"><a href="#分模块画子图" class="headerlink" title="分模块画子图"></a>分模块画子图</h5><p>[New Schmatic]-[New Page]创建子图。然后放置元件，重点检查元件标号(Part Reference)和封装(PCB Footprint)，修改value。快捷键H，V，R可分别左右、上下调换元件和旋转元件。<br>放置电源、GND符号，端口符号等，然后wire连接逻辑关系。</p>
<h5 id="指定net-alias"><a href="#指定net-alias" class="headerlink" title="指定net alias"></a>指定net alias</h5><p>一般与端口相连的网络名称应与端口名称相同。网络标号只在Page内起作用，因此不同Page中的网络标号是可以相同的。</p>
<h5 id="在顶层图中放置子模块"><a href="#在顶层图中放置子模块" class="headerlink" title="在顶层图中放置子模块"></a>在顶层图中放置子模块</h5><p>[Place]-[Hierarchical Block]。缺省情况下，所有的输入都在左边，所有的输出都在右边，可以根据绘图需要进行调整。<br>若修改了Page中的设计，如使用Place H pin增加、减少了Port，可以在Block处使用[Synchronize Up]命令，更新Block。如果在Block上增加了Port或减少了Port，则可以使用[Synchronize Down]。  </p>
<h5 id="原理图复用"><a href="#原理图复用" class="headerlink" title="原理图复用"></a>原理图复用</h5><p>一个Schematic作为一个Block在顶层中可以复用。<br>原始的属性所代表的元件，称为Instance，对应属性页中的白色一列；而由于复用新增的两列所代表的多个同类元件，称为Occurrences，对应属性页中的黄色列。在存在复用的设计中，Occurrences中的属性(可不同)，才是真正使用的属性(在导出PCB网表时使用)。  </p>
<h5 id="电路模块级的重用"><a href="#电路模块级的重用" class="headerlink" title="电路模块级的重用"></a>电路模块级的重用</h5><p>可将一整个已有的电路设计复用，原理图对应相应的.dsn，PCB布局对应相应的.mdd（需要在PCB中添加至Module Path中）。其中可重用DSN原理图中的元件经过特殊处理，具有Reused ID属性。若被外部引用的DSN名为DsnName；而DSN中被引用的schematic名称为SchName，则对应的MDD文件名称应为DsnName_SchName.MDD。在PCB设计时，.dsn和.mdd通过文件名来匹配。<br>[Place]-[Hierarchical Block]-[Browse…]找到复制过来的xx.dsn（设置文件名才能与PCB中的.mdd匹配）。<br>在[Browse]选择文件后，Path and filename中为DSN文件的完整路径，为保证整个Sch目录复制到别的机器或目录还能改正确打开原理图，必须将其改为相对路径。  </p>
<h5 id="分配元件标号"><a href="#分配元件标号" class="headerlink" title="分配元件标号"></a>分配元件标号</h5><p>选中.dsn—annotate。注意Action中Unconditional reference update一般不使用，另Reset reference numbers to begin at 1 in each page也绝对不能选中，会导致标号重复。<br>第一步：将页面中的标号都置为“？”。Scope选Update entire design，Action选Reset intersheet References，Mode选Preferred，选中Include non-primitive parts（即将Block也标号），确定即可。<br>第二步：若没有使用外部重用模块（.dsn .mdd），则Action选中Incremental reference update确定即可。若使用了外部重用模块，则在Allegro Reuse中标号。  </p>
<h5 id="DRC电气规则检查"><a href="#DRC电气规则检查" class="headerlink" title="DRC电气规则检查"></a>DRC电气规则检查</h5><p>DRC检查管脚连接冲突、总线宽度匹配，短路（同一个元件管脚上有多个网络名）等原理图设计中潜在的错误。检查范围有限，可能误报，需谨慎仔细查看。<br>Edit—browse—DRC Markers可查看检查出的错误。  </p>
<h5 id="网表导出netlisting"><a href="#网表导出netlisting" class="headerlink" title="网表导出netlisting"></a>网表导出netlisting</h5><p>在导出网表之前必须将所有元件的PCB Footprint属性填好（如果某些元件的封装还没有画，也要先填一个名字）。<br>Tools—create netlist，在PCB editor页面选中Create or Update Allegro PCB Editor Board，若是修改了原理图更新PCB，则要选择input board。Place changed需要注意下。  </p>
<p><strong>一定要注意在打开的PCB中另存至pcb文件夹中！！！这是血泪的教训啊！！！不然再次导出是要被覆盖的啊！！！</strong>  </p>
<p><strong>注意</strong>：导出时若遇到ERROR(ORCAP-36004)，是对多part元件编辑时，软件会自动给编辑的part添加尾缀造成多part不一致，在Edit part页面选择Options-Package properties删掉尾缀。若是有多次编辑，则会提示错误封装名重复。这时进Design Cache将相应的封装用自己的库替换掉。注意以后要避免直接修改Part封装导致这种错误，而要在库中修改再替换。  </p>
<p><strong>注意</strong>：可以使用edit—browse—选择相应的器件进行修改。比如修改part的footprint，就可以进入part，选择需要修改的元件，ctrl+E修改属性里的footprint。修改port、net的名称也可以这样做。<br>也可以Ctrl+F查找器件，如查找所有电阻，则在查找选项里选中parts，然后搜索R*，即可选中所有的电阻进而修改footprint。<br>也可以直接选中一页或.dsn，右键选择edit object properties。</p>
<h3 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h3><p>备注：1 mil=1 inch/1000=25.4mm/1000<br>1 mm=39.37…mil≈40mil  </p>
<h4 id="制作焊盘"><a href="#制作焊盘" class="headerlink" title="制作焊盘"></a>制作焊盘</h4><p>Pad Designer-Parameter中，type焊盘类型有：Through通孔、Blind盲孔、single单层，其他参数自己看看吧。<br>Layer中，需要定义每层的参数。一般需要定义的信号层有Begin Layer、Default Internal、End layer（对于过孔来说就这三个层就足够了，中间层都会用Default internal的参数自动匹配），另外非信号层一般还需要定义：Soldermask_top、Soldermask_bottom(阻焊）。在设计PCB时，阻焊层（Soldermask_top和Soldermask_bottom）是反向显示的，即不涂阻焊材料的地方是一个填充的图形，覆盖阻焊的地方没有图形。PCB上一般只有焊盘上不会覆盖阻焊材料，其它的连线、铺铜都被阻焊材料覆盖。一般直径要多设10mil。  </p>
<p>Regular Pad是通常意义下的焊盘，大小根据datasheet设定，一般焊盘宽度应该大于至少等于管脚宽度，焊盘长度两倍于管脚长度使之对准中心（焊盘间距5mil以上没问题）；Thermal Relief是焊盘要与周围敷铜连接时的状态，若焊盘和周围铺铜的网络相同，会自动用4或8条将焊盘与周围铺铜连接，周围铺铜与焊盘边缘隔开的距离是Regular的半径和Thermal Relief半径之差，建议直径多设12mil；Anti Pad是焊盘与周围的铺铜网络不同（因该绝缘开）时隔离的形式。  </p>
<p>总结下来涉及到的数据有：<br>Drill diameter    按需<br>Regular Pad    按datasheet，焊盘宽度大于等于管脚宽度最大值，焊盘长度两倍于管脚长度中间值<br>Thermarl Relief    大12~16mil (0.3~0.4mm)<br>Anti pad    大12~16mil (0.3~0.4mm)<br>Soldermask    直径大regular pad 8~10mil，长宽都大8~10mil (0.2~0.25mm)  </p>
<h4 id="制作封装package-symbol"><a href="#制作封装package-symbol" class="headerlink" title="制作封装package symbol"></a>制作封装package symbol</h4><p>用封装来表示元件管脚、物理尺寸以及管脚位置等信息。不同的元件如电阻、电容可能会用相同的封装，如0402、0603。<br>PCB封装只代表器件的尺寸大小等物理特性，封装上的管脚本身没有任何电气属性；而原理图符号是一个器件电气上的抽象表示，代表着器件管脚的输入、输出等电气属性，但符号本身不包含尺寸、管脚位置等物理特性。</p>
<p>原理图中符号通过PCB Footprint属性与PCB封装库中的同名封装对应；原理图符号上的管脚与封装的对应焊盘对应（管脚号与焊盘号对应）.<br>一个package symbol与两个文件对应：.dra文件可编辑；.psm不可编辑，由.dra生成，需添加至psmpath。  </p>
<p>Allegro中有很多对象都叫symbol，如Mechanical Symbol（机械符号）、Format symbol（图纸格式符号），Shape symbol（形状符号，画异型焊盘时能用到），以及Flash symbol（在焊盘设计中用来确定特殊形状的Thermal和anti Pad）。这些符号设计阶段都是*.dra文件，然后生成对应的symbol文件，但扩展名是xxm(xx是其它字母）。在PCB设计时，如果要使用这些symbol，都须要把xxm所在目录加入design_path中。  </p>
<p>注意几个概念：<br>Ref Des–reference designation元件标号在Silk Screen层，如U<em>,R</em>,C*等；<br>封装占用面积，用Place_Bound_Top画一个封闭区域(Shape)来表示；<br>Package Geometry封装轮廓在Silk Screen层，生产时与Ref Des的Silk Screen合并成一个光绘文件，用于在PCB表面印字。  </p>
<p>具体步骤  </p>
<ol>
<li>模板向导<br>[File]-[New]- Package symbol(wizard)——选择类型、模板——<br>确定管脚数(N)，管脚间距(e)必须精确，焊盘中心距离（e1）取偏大（就最大宽度），封装外形丝印的宽度（E）取最小、高度(D)取最大——选择焊盘padstack——选择参考坐标symbol origin，并选中Do not create a compiled symbol在后续创建。  </li>
<li>修改封装<br>调整grid以便编辑——添加1管脚标注：选择圆形Shape–Option页选择Active Class and Subclass为“Package Geometry和silk_screen_Top—选择圆心在管脚1右边—命令行ix 0.5（单位mm）确定半径。</li>
<li>生成符号文件.psm<br>[File]-[Create Symbol]生成PCB设计使用的Symbol文件。一般将所有封装的Symbol文件都放在一个目录下以备使用。  </li>
</ol>
<p><strong>注意</strong><br>封装符合要求的条件：合适的焊盘大小；精确的焊盘间距；Component—Ref Des—Silkscreen 层元件标号前缀；Package Geometry— Silkscreen层元件外形轮廓； Package Geometry—Silkscreen层绘制极性方向、1管脚方位；[Setup]-[Aereas]-[Package Boundary]定义元件实际PCB面积。（用向导绘制基本上已经概括完了）<br>Package Geometry的Silkscree_Top以及Component—Ref Des元件标号中的Silkscreen_Top在后续处理中会作为PCB顶层丝印的一部分；<br>Commond命令：<br>x 10 20 : 将鼠标定位在绝对坐标 (10,20)处<br>x 20 : 不改变上一次鼠标点击的y坐标，将x坐标定位在x坐标为20处<br>y 30: 不改变上次点击的x坐标，将y坐标定位在30<br>ix 10 20：相对于上次点击的位置，x向右移动10，y向上移动20<br>ix -10：相对于上次点击的位置，x向左移动10<br>iy 10：相对于上次点击的位置，y向上移动10  </p>
<h4 id="制作机械符号（画外框）"><a href="#制作机械符号（画外框）" class="headerlink" title="制作机械符号（画外框）"></a>制作机械符号（画外框）</h4><p>PCB机械符号包括：</p>
<ul>
<li>PCB的外形、尺寸要求；</li>
<li>PCB的安装固定要求；</li>
<li>系统中其它部件在PCB上安装固定的要求，抗冲击的PCB上的金属加强结构</li>
<li>PCB上禁止布线、和放置元件的区域（或允许布线、放置元件的区域）</li>
<li>PCB上接插件放置的位置</li>
<li>PCB在制造过程中切割、倒角等要求等  </li>
</ul>
<p>需要制作Mechanical Symbol的场景：完全自由设计，比如设计一个实验板，可以自由定义板子的外形、尺寸等。这种情况不用设计专门的Mechanical Symbol，只需在PCB设计环境用Board Geometry用line画一个框即可定义电路板的外形。<br>不需要制作Mechanical Symbol的场景：多种PCB使用同样的机械定义，如同一种形式的板子会设计很多种；由业界标准定义的PCB，如PCI板卡、VME、CPCI板卡等；设计好后可以反复利用。<br>下述的处理不管在需要制作Mechanical Symbol的场景，或是直接在工程中画外框的场景都会用到：  </p>
<ul>
<li>设置图纸大小：[Setup]-[Design Parameter]-[Design]，设置单位和Extents，确定原点和宽高。</li>
<li>画PCB外框：选择[Add]-[Line]菜单，再选择右侧属性页中的子类为Board Geometry–Outline；根据尺寸输入命令确定外框。注意画外框时要一条边一条边地画，否则后面倒角不能选择segment。</li>
<li>倒角：[Manufacture]-[Drafting]-[Chamfer]命令，在右侧的Option窗口输入Trim Segments和Chamfer angle为：First2；Second0；Chamfer angle45；若是倒圆角则选择Fillet。</li>
<li>安装孔：Add Circle、Add Line。画好一个孔后，使用复制功能，并iy/ix至相应位置。</li>
<li>添加尺寸标注：[Manufacture]-[Dimension Environment]，右键选择Parameter设置单位，右键选择需要的标注项进行尺寸标注。  </li>
</ul>
<h4 id="画图前的设置"><a href="#画图前的设置" class="headerlink" title="画图前的设置"></a>画图前的设置</h4><h5 id="层叠结构Cross-Section"><a href="#层叠结构Cross-Section" class="headerlink" title="层叠结构Cross Section"></a>层叠结构Cross Section</h5><p>[Setup]-[Cross-section]：添加层的属性，Layer Type中Conductor为通常用于走信号线的层、Plane为平面用于电源或地（平面即整一层铺铜均属同一个网络，有时一个平面可分割成多个区域用于不同的电源或地，注意需保证其较大面积和低阻抗连接路径）。  </p>
<p>常用的层叠结构有：双面板TOP BOTTOM；四层板TOP GND1 PWR1 BOTTOM；六层板TOP GND1 SIG1 SIG2 PWR1 BOTTOM；八层板TOP GND1 SIG1 PWR1 GND2 SIG2 PWR2 BOTTOM。</p>
<h5 id="设置工作路径Design-Path"><a href="#设置工作路径Design-Path" class="headerlink" title="设置工作路径Design Path"></a>设置工作路径Design Path</h5><p>[Setup]-[User Preferences]-[Design Path]：module path为复用MDD文件路径；PAD Path为焊盘路径；Psm Path要设置用到的所有symbol的路径，包括packages symbol(psm–pcbsymb)，mechanical symbol(bsm–pcbMechSymb)，以及pcbFlashSymb，PadShapes；</p>
<p>添加过孔：Constraints-Physical-All layers选择Vias添加需要用的过孔。</p>
<h5 id="设置图纸大小、单位、边框、颜色"><a href="#设置图纸大小、单位、边框、颜色" class="headerlink" title="设置图纸大小、单位、边框、颜色"></a>设置图纸大小、单位、边框、颜色</h5><p>参考上小节制作机械符号。<br>颜色可使用已有的script。另一种方法：在已有板子的基础上且层叠结构的名字一致，可export-parameter选中color相关参数，再在需导入brd中import-parameter。</p>
<h5 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h5><p>Command中键入echo $localenv找到env文件的路径。打开env（没有就自己创建）,在一堆#前输入快捷键命令。如alias ~E move(注意这里要大写)，funckey w add connect。注意alias命名的可在Command输入但不能设置单键，而funckey则可以设置单键。<br>可在Tools-Utilities中查看支持的键盘命令以及已有的快捷键。</p>
<h4 id="敷铜"><a href="#敷铜" class="headerlink" title="敷铜"></a>敷铜</h4><p>Shape–Polygon敷铜(可Edit—Z-copy复制平面到另一层)。<br>方法一：敷铜前可以先选择相应的电源/地net高亮，然后再在Shape中选择net画形状，注意拐角取45度。<br>方法二：先画好一整块敷铜，再Anti Etch分割平面。  </p>
<p>Shape—Edit Boundary可任意更改敷铜的边界。注意敷铜与过孔的连接可在Shape—Global Dynamic Params中修改，热风焊盘Thermal relief connects中连接方式一般Full connect或Orthogonal正交。<br>需要在敷铜中间挖空时，选择Shape—Manual Void。<br>不同电源信号的敷铜间隔最小可至0.2~0.3mm。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>PCB中灰绿色的连线叫做(Rats)，表示需要连接而还未连接的网络；<br>[Place]-[Quick Place]：可将剩余的所有元件都暂时放到PCB中，再慢慢摆位置；<br>可通过与原理图互动来选择元器件。这样可以根据信号的流向来逐个放置元件，有利于边放置边检查电路原理图，同时也利于根据元件的功能来考虑放置位置。  </p>
<h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><p>可在[Display]-[Show Rats]-[Components]选择显示相应器件的飞线。<br>走线宽度一般不小于6mil(0.1524mm)，线间距以3W原则即：走线中心之间距离至少为线宽的三倍，这样可使走线在另一走线的70%磁通量边界范围外，若要到98%，线间距需大10倍线宽。<br>差分线的线宽和线距理论上是用工具计算的（SI9000），但是没用过…目前用过的线距/线宽有8/4.5、6/4 mil。<br>注意绕线的时候，一般选择3x space。</p>
<h5 id="差分线"><a href="#差分线" class="headerlink" title="差分线"></a>差分线</h5><p>在Setup-Constrains-Constrains Manager中的Electrical-ECS设置布线规则，重点在等长（Static Phase），视具体情况可设为5mil(0.127mm)；然后在Net中为差分对绑定相应的规则。</p>
<p>总线做等长约束在Relative Propagation Delay中Create Match Group再定义约束参数。注意参数中的Delta:Tolerance，Delta指需要设置的值与Target的差值，设为0即可；Tolerance指可容忍的延迟差值，按需要设为0.2~0.3mm或者更大。<br>在Physical中设定宽度（Line Width）等参数；<br>在Spacing中为差分对设定对与对之间的间隔（Line to All）,似乎在Ecs和Pcs中设定的Gap优先级更高，这里设定Line to line应该只对差分对之间起作用。注意！在ECS中要设置Min Line Spacing的值，否则会提示间距错误的DRC。<br>设定差分对时进入Auto Setup设置后缀后可自动设置。<br>注意在Setup-Constrains-Mode中将需要检查的DRC打开，否则不会显示。</p>
<h5 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h5><p>Fanout，在焊盘引脚附近打孔再连接线。可在Route-PCB router-fanout by pick选择symbol自动扇出，右键Setup可进行相关设置。若对连线有要求可先在Constrains manager中修改默认走线宽度。</p>
<h5 id="Xnet"><a href="#Xnet" class="headerlink" title="Xnet"></a>Xnet</h5><p>约束走线等长时，会遇到一个电阻/电容连接的两根线看做同一条net来约束长度的情况，此时需要将这个电阻两端的net组合为Xnet。<br>方法：Analyze—Model Assigment—选择需要设置的电阻/电容—进入设置页面选择对应管脚—Ok。然后再在约束管理器中选择Xnet约束等长。</p>
<h4 id="制板"><a href="#制板" class="headerlink" title="制板"></a>制板</h4><p>光绘文件和钻孔文件；<br>说明所制作PCB的厚度，各层的重叠顺序（如对PCB上走线的阻抗等有特殊要求，一般应指出层叠结构、介质类型）；<br>明确最小线宽、最小线距、最小钻孔等加工工艺；</p>
<h4 id="复用模块"><a href="#复用模块" class="headerlink" title="复用模块"></a>复用模块</h4><ol>
<li>在原理图中，选择根项目 Annotate-PCB Editor Reuse，选择Generate Reuse module并确定后，选择原理图中所有器件右键Edit Properties，能看到每个器件有唯一的Reuse ID属性，说明复用模块生成成功。</li>
<li>从原理图生成PCB布局布线完成后，选择Tools-Create Module，框住所有器件并选择原点，另存为mdd复用模块，注意名字必须是原理图项目名_根page名的级联。</li>
<li>在需要用复用模块的原理图中，新建Hierarchical Block，Implementation Type选择Schematic View，Path选择复用模块.dsn，Implementation name选择复用模块Page名称。摆放完成后，在Tools-Annotate中选择PCB Editor Reuse，Function中选择Renumber design for reuse module，并在对下方选择好复用模块，这样就完成了复用模块在工程中的标号。生成PCB后在Place-Manually中选择Module Instance摆放至相应位置即可。  </li>
</ol>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>在电源之间转换时，会用电感用于两种不同电源之间的滤波。  </p>
<p>电源芯片根据所连接芯片的功率（电流）进行选择，同时考虑效率、纹波、封装等因素。</p>
<p>使用LDO(Low Drop Out)电源芯片时，注意Dropout voltage的值，输入一般不能等于输出电压，需更高。</p>
<p>电源芯片对滤波要求较高，datasheet中一般会有layout建议，如滤波电容放在芯片同一面等，按照建议来布局布线。</p>
<p>去耦电容的布置尽量靠近电源管脚，且容值越小的越靠近。过孔最好打在电容的同一侧靠近。</p>
<p>在设计AD/DA/CLK等带模拟信号的电路时，用电源芯片将供电电源隔离，以减少干扰。其他芯片对电源有要求时同理。  </p>
<h4 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h4><p>FPGA会要求大电容（Bulk Capacitor）滤掉低频、陶瓷电容滤中频，个数和数值在User Guide中有推荐，如7系列在UG483-PCB中。位置要求等也会有推荐。  </p>
<p>Xilinx在GU1099中有BGA封装的推荐走线方式。包括宽度、距离、过孔大小等。差分线对走FPGA内部，可以选择neck mode使两线走两via之间，参数参考GU1099，注意适当选择gridless方便内部走线。  </p>
<p>注意单端clk信号连接至FPGA的全局时钟管脚时，要连接至p端，不能连接至n端。</p>
<p>XILINX的FPGA的BANK分为HP/HR两种，所支持的电压、IOSTANDARD（如LVDS/LVDS_25）不同，需要注意。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[入vivado坑之联合modelsim仿真]]></title>
      <url>http://bonewp.github.io.git/2017/02/22/%E5%85%A5vivado%E5%9D%91%E4%B9%8B%E8%81%94%E5%90%88modelsim%E4%BB%BF%E7%9C%9F/</url>
      <content type="html"><![CDATA[<p>最近跟着调PCIE接口，要用Xilinx高端大气上档次的vivado开发环境，然而新入就是坑啊，泪目。</p>
<p>首先背景是，已有在其他电脑上可编译可仿真的工程，在我电脑2016.2版本vivado上可综合通过，但是联合modelsim仿真卡在compiling一步， 于是放弃2016.2版本，装了其他电脑一样的2014.4版本，结果就是漫无止境的填坑过程…</p>
<a id="more"></a>
<p>问题是，联合modelsim进行仿真时，始终会出现错误<code>(vlog-2155) Global declarations are illegal in Verilog 2001 syntax.</code>，根据理解和网上搜索结果，是因为对应的<code>function.vh</code>文件里有<code>function</code>函数，但<code>function</code>和<code>task</code>不能定义在<code>module</code>之外，而调用文件中<code>`include &quot;function.vh&quot;</code>在<code>module</code>之外，导致出错。若改为vivado自带的仿真器，则会有错误<code>Root Scope Declartion Not Allowed In Verilog 95/2k</code>，应该也是同样的错误。  </p>
<p>神奇的地方在于，按照语法标准来说这确实会出错，但在之前的调试人员电脑上居然能够正常通过，于是找寻各种方法想在不修改源文件的情况下能编译通过。其中搜到的有价值的信息中，有提到过单独定义<code>function</code>和<code>task</code>的<code>.vh</code>后缀文件不加入modelsim仿真编译，但如何才能让其不编译这个文件就是个迷了。</p>
<p>经过两天的苦苦尝试，换了modelsim版本，重装了vivado2016.4，最后还是采用的修改源文件的解决方法，把调用的<code>function</code>全都集中在<code>function.vh</code>文件中，再把<code>`include &quot;function.vh&quot;</code>命令放在<code>module</code>定义里面，而包括了<code>\</code>define<code>命令的</code>.vh<code>文件则保持放在</code>module`定义之外。</p>
<p>最终结论，单独定义<code>function</code>和<code>task</code>的头文件要放在<code>module</code>中调用，而至于为什么之前的电脑上没这么做却通过了，未知…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初次使用sway]]></title>
      <url>http://bonewp.github.io.git/2016/10/24/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8sway/</url>
      <content type="html"><![CDATA[<p>前一周准备开题，时间紧脑袋一热没有用ppt，转去用了sway，本来想的目的是不用去调效果、动画，结果不熟悉sway的组织结构，为了达到理想的效果试了很多次，最后演示的时候还因为图片大小问题没演示好。<br>这里把使用经验总结一下，以后再使用好复习。  </p>
<a id="more"></a>
<ol>
<li><p>sway是以图片为重点的，注意sway中的插图尺寸要均衡，不能长宽比过大或过小。<br>像在visio里做的框图若直接源宽高导出，可能会比例失衡，而先放到word里再另存为图片的图，插入的效果就比较好，这是因为图片长宽比按word里的格式保存的；而在visio直接导出时，一定要确定好长宽参数。  </p>
</li>
<li><p>小单位组织为网格时，要按照自己的逻辑去组合，而不是为了达到某种效果而去组合某几个文本/图片。<br>这是由sway全平台自适应的特点决定的，在PC某一分辨率下看组合的网格是某一种样子，而到了另一分辨率或者手机上时，单元layout就会不一样了。所以一定按照自己的逻辑去安排组织结构，我认为这也是sway的设计初衷：<strong>作者仅需要关心文本/图片的逻辑关系，剩下的效果等工作由sway自动完成</strong>。  </p>
</li>
<li><p>垂直滚动的布局比较全能，对各平台的支持都较好。<br>我一开始看第三种适应性布局比较炫，就先试了，然后过了一段时间发现对应当时的文本效果不是很好，然后又转用水平滚动的，结果演示时由于我的图片有些过宽显示不全，演示效果不是很好，最后才发现，我应该使用垂直滚动的布局，对宽图片和文字都能得到比较好的展示，看起来也没有水平滚动那么晕。<br>作为官方采用的默认推荐还是有道理的。  </p>
</li>
</ol>
<p>总结使用就是：选好布局（一般垂直滚动），选好颜色样式，将图片和文字按逻辑整理好即可。<br>总之sway是比较好用的的，云存储，易于分享，上手后使用简单；缺点uwp应用会闪退，还是网页端好用点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[任务书中指标要求的重要性]]></title>
      <url>http://bonewp.github.io.git/2016/10/13/%E4%BB%BB%E5%8A%A1%E4%B9%A6%E4%B8%AD%E6%8C%87%E6%A0%87%E8%A6%81%E6%B1%82%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>这个星期在做硕士论文开题，中间刘老师提到了一句话，让我有种豁然开朗的感觉，大致意思就是：</p>
<blockquote>
<p>论指标论好了，把选型和方案确定，就可以说一个项目做了一半了，剩下的就是结合细节去实现。  </p>
</blockquote>
<p>这让我对现在即将参与和之前负责的项目有了新的认识。自己以前就是个打杂工，老师已经确定下了具体的方案，自己照着去执行就行了，并没有发现有什么问题，还自我感觉良好。<br>但是自己在上一个做的USB体制下的卫星模拟器时，就感觉到了任务指标与设计方案的重要性。自己半路从张老师手中接收过来，从画板子开始。结果板子画完自己写程序写到FPGA管脚分配时，发现7系列的FPGA的HR Bank和HP Bank的区别，特别是管脚电压与AD/DA/CLK芯片的不匹配，进一步又发现了供电电压也给错了…充分暴露了方案设计时的论证不充分，接着就调板子之后再改第二版，结果在第二版调试全部完成之后，发现AD前级缺少模拟AGC，接收功率动态范围根本达不到…  </p>
<a id="more"></a>
<p>从这次经历可以看出来，一方面是使用新的芯片特别是用FPGA时，要对其特性有充分的考察；另一方面就是重点了，要结合任务指标要求，设计好方案及选型，以能达到指标要求。像是第二点，如果在方案设计时就注意到了动态范围的要求，就不会忘记加模拟AGC了。<br>说了这么多话，其实说到底，就是设计方案的重要性以及其难度。就像在组织中领导的重要性，决定好了方向，下级实施者才知道怎么去做，这需要大量的经验基础和专业知识，毕竟下级做着做着做不下去了，可不是实施者的错，是领导决定方向的锅。项目的方案就是领导方向，充分论证了咱们用这些芯片、这种结构能实现目标要求，咱们才接着去干，否则就会发生各种我之前遇到的，做都做完了发现某个地方不对，这时候已经耗费了大量资源了。<br>当然，不会说一点错误都不范，只是在已知范围内尽量地减少错误发生，毕竟未知情况多得去了。<br>最后就是对现在的项目，刘老师提醒了我几次，深入地去认识任务书的要求，为什么要这么要求，我们设计方案时选用这种芯片/结构为什么这么选、能够对应实现要求中的哪个指标，都能搞明白了，也就对这个项目认识了一大半了。<br>所以说呐，作为一只小硕，还是好好地去看任务书和方案吧，只是画画/调调板子、写写程序还是远远不够哒。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FM调制与解调]]></title>
      <url>http://bonewp.github.io.git/2016/09/24/FM%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/</url>
      <content type="html"><![CDATA[<p>之前做的项目中有FM调制解调的算法，然后重新拾起通信原理来复习，惊奇地发现我脑子里记得FM信号表达式一直是错的…简直是再一次对不起学通信这个名号啊（我为什么要说又..）  </p>
<p>首先我知道FM的频率表达式是$f=f_0+f(t)$，然后我理所当然地、头脑短路地认为FM信号表达式为$f(t)=A\cos[2\pi(f_0+f(t))+\theta]$。简直啪啪地打脸…完完全去去地错误，我还天真地以为这是正确的表达式好长一段时间。  </p>
<p><strong>正确的思路</strong> 应该是由频率表达式得出全相位表达式，进而得到余弦信号表达式。<br>首先知道瞬时角频率为$\omega_F(t)=\omega_c+K_F\upsilon(t)$<br>由于调频波在不同时刻的旋转角频率不同，则从$t=0$到$t$时刻所旋转的全相角为瞬时角频率在此时间间隔内的积分，即$\psi_F(t)=\int_0^t\omega_F(t)\,dt=\omega_ct+K_F\int_0^\lambda\upsilon(\lambda)\,d\lambda+\theta_0$<br>那么FM信号的表达式即$\upsilon_F(t)=V_{cm}\cos[\psi_F(t)]=V_{cm}\cos{\omega_ct+K_F\int_0^\lambda\upsilon(\lambda)\,d\lambda+\theta_0}$  </p>
<a id="more"></a>
<p>相比较而言PM的表达式就只是少了一个积分号$\upsilon_P(t)=V_{cm}\cos{\omega_ct+K_P\upsilon(t)+\theta_0}$<br>扩展一下，接收机中可以统一使用PM调制解调，而当要使用FM时，调制模块先对输入信号作积分，解调模块对输出信号作微分即可实现FM。  </p>
<p>而除了刚才提到的PM解调后微分的方法，FM解调还可使用鉴频器的方法，先偷个懒截图上原理。待后续填坑。<br><img src="/2016/09/24/FM调制与解调/FM解调_鉴频.png" alt="FM解调_鉴频.png" title=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[超外差的概念]]></title>
      <url>http://bonewp.github.io.git/2016/09/24/%E8%B6%85%E5%A4%96%E5%B7%AE%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>本科时学习通信原理就接触了超外差式(superheterodyne)接收机，也知道超外差式接收机的原理和框图，现在做了一些相关项目对此类功能也是熟悉了很多，但就是从来没去关注过为什么叫做超外差这么个奇怪的名字。<br>这两天赶硕士论文开题，补《雷达系统及其信息处理》，在雷达接收机章节中又看到这个词，才重新细细思考起这个词儿，然后突然觉得自己简直对不起学通信这个名号…连超外差这个词过了几年才明白。  </p>
<p>首先从这个词的起源说起，超外差来源于外差(heterodyne)，引用百度百科上的说法  </p>
<blockquote>
<p> heterodyne（外差原理）来自于希腊语的词根hetero（不同的）和dyn（功率）。<br>外差法的英文原意应该是 “不同频率信号作为驱动力的方法”, 用汉语可凝练成 “异频驱使法”, 再进一步, 就变成 “外差法” 了. 这个从外差法专利文档中也可以得到印证, 其在最后的保护范围声明中, 斐德森一口气开列了 9种情况, 核心内容都是”用两个以及两个以上频率的信号相作用产生新的频率的方法”。  </p>
</blockquote>
<p>也就是说本质是利用两个频率混频之后的结果得到所用信号的频率。一个词总结就是<strong>频谱搬移</strong>。<br>尼玛原来频移的技术是这么引入进来的，我现在做的硬件很多都在搞上/下变频、升/降采样，都跟着玩意儿有关，搞了这么久才知道精髓原来就是外差…  </p>
<a id="more"></a>
<p>再回到超外差，从名字可看出，超外差就是由外差发展而来的，引用维基百科的说法  </p>
<blockquote>
<p>超外差接收机是一种利用超外差原理的无线电接收机，1918年由美国无线电工程师埃德温·霍华德·阿姆斯特朗发明。超外差原理是一种利用机器内一个可变的振荡器产生的电波和外来信号混合以产生固定频率的中频信号。  </p>
</blockquote>
<p>也就是超外差多了一个从射频到中频的过程，这样接收处理就相对容易了，涉及到中频滤波等等。<br>其框图、优点之类的不再赘述了，百科中都有，总之超外差这个概念弄明白了，那么接收机的原理基本上也就有个数了。</p>
<p>reference:<br><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%A4%96%E5%B7%AE%E6%94%B6%E9%9F%B3%E6%9C%BA" target="_blank" rel="external">超外差收音机-维基百科</a><br><a href="http://baike.baidu.com/view/1029112.htm#reference-[1]-1029112-wrap" target="_blank" rel="external">超外差-百度百科</a><br><a href="http://baike.baidu.com/subview/5032345/5035457.htm" target="_blank" rel="external">外差原理</a>  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[usb体制及测控技术相关]]></title>
      <url>http://bonewp.github.io.git/2016/08/25/usb%E4%BD%93%E5%88%B6%E5%8F%8A%E6%B5%8B%E6%8E%A7%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>最近做的项目是基于USB体制下的相关算法，于是找了些资料把这个体制给了解了一下，在此做一下总结。</p>
<h3 id="USB体制来源"><a href="#USB体制来源" class="headerlink" title="USB体制来源"></a>USB体制来源</h3><p>USB(Unified S Band)全称统一S波段测控体制，最早是由美方提出并在1966年用于“阿波罗”登月计划，为解决原测控网中多种频段设备的复杂、电磁兼容性差、作用距离不够等问题缺陷，将跟踪测轨、遥控、遥测综合为一体，为测控技术发展史上的一个里程碑<sup><a href="#1">[1]</a></sup>。</p>
<blockquote>
<p>到1979年，世界无线电管理会议决定以S波段作为空间业务频段以后,更促进了USB的进一步发展。到了80年代，USB又被纳入国际空间数据系统咨询委员会(CCSDS)标准，并已为世界上多数国家共同接受，为有利于开展国际合作，世界上许多国家都按此建造统一S波段系统，使USB得到了进一步的推广和发展。世界上各航天国家如：中、美、前苏联、法、日、德、巴、印以及国际航天组织（如欧空局、阿拉伯卫星通信组织，亚州卫星通信组织）都相继建立了自己的USB和UCB(统一C波段)测控系统，使统一载波测控系统如雨后春笋般地出现在地球上。</p>
</blockquote>
<p>在找到的一篇<a href="http://public.ccsds.org/" target="_blank" rel="external">ccsds</a>介绍中提到了我国最早应用USB体制的卫星<sup><a href="#2">[2]</a></sup>：</p>
<blockquote>
<p>从九十年代开始我国的航天测控系统开始采用统一S波段测控体制（USB），在射频与调制的物理层采用了CCSDS标准，与此同时我国也在链路层以上的高层协议上研究采用CCSDS标准。1999年5月10日发射的实践五号卫星，在我国是第一个采用 USB测控体制的航天器，也是第一个采用CCSDS-AOS高级在轨系统标准的航天器。此后我国与欧空局合作的空间科学探测项目“双星计划”的两颗卫星“探测一号”和“探测二号”卫星的数传数据不但完全采用CCSDS-AOS高级在轨系统标准，而且向CCSDS组织正式申请了飞行器识别符。</p>
</blockquote>
<h3 id="USB基本原理"><a href="#USB基本原理" class="headerlink" title="USB基本原理"></a>USB基本原理</h3><p>测控通信系统是卫星系统的五大系统之一、载人航天系统的七大系统之一，完成对飞船的测轨、遥控、遥测、话音通信和电视传输等重要作用<sup><a href="#3">[3]</a></sup>。<br>对于遥测、遥控、测速等概念可参考文献<a href="#4">[4]</a>。</p>
<blockquote>
<p>国际上对于航天测控定义为：“Tracking, Telemetry&amp;Command”(缩写TT&amp;C)，中文通常称“跟踪，遥测及遥控”。  </p>
</blockquote>
<a id="more"></a>
<p>相对于以前不同功能采用不同载波的方式，USB体制如其名字所体现的是“统一载波”：将遥测、遥控、跟踪信号先用bpsk调制在多个副载波上，再用PM调制在一个载波上，进而搬移至S波段发射。在接收上与调相对应的锁相技术是其重要技术之一。<br>文献<a href="#3">[3]</a>中总结了载人航天USB测控系统的综合化、高可靠性、高测轨精度、抗组合干扰、数字化、大动态控制、目标快速捕获等关键技术。其中对综合化中的“五合一”信号设计，我觉得可以帮助理解USB体制的特点：</p>
<blockquote>
<p>“五合一”信号设计<br>(1) 频分制的下行双载波: 一个用于测控(TT&amp;C)，另一个用于数传(DDT)。TT&amp;C 和 DDT 可同时存在。<br>(2) 频分制的 TT&amp;C 副载波： 下行为遥测和测距音组三种副载波，上行为遥控、话音和测距音组等四种副载波， TT&amp;C 载波采用调相/调相(PM/PM)调制。<br>(3) 时分制的 DDT 载波: 完全用作数据传输，采用 PCM/QPSK 调制。以2兆比特/秒码速传输下行话音、电视、遥测、GPS、交会雷达和科学实验数据等多路信息。<br>(4) FM 遥测载波： 航天器可用另一个载波发射高码速的遥测信号，调制方式为 PCM-FM 。 TT&amp;C 和 FM 可同时存在，为频分工作。</p>
</blockquote>
<h3 id="相关发展及感想"><a href="#相关发展及感想" class="headerlink" title="相关发展及感想"></a>相关发展及感想</h3><p>虽然吹了USB体制这么多，目前也确实是相对成熟的一套体制，，不过其一些缺点不足我觉得也是有的，如设备重复度高，这是频分复用的特点造成的；保密的问题；多目标测控时副载波之间的干扰等。<br>为了往未来天基测控进而深空测控的方向发展，其使用的各种技术都还会提升，如使用扩频测控，频带往更高的频段发展等等。当然这些都是后话了，作为一个小硕我还是老老实实地去想算法写代码吧 ( &gt;﹏&lt;。)～</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><span id="1"> </span> 刘嘉兴. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=9&amp;CurRec=1&amp;recid=&amp;filename=DATE902.000&amp;dbname=CJFD9899&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;uid=WEEvREcwSlJHSldTTGJhYlRaSXVoREFFTWF3MEF2VFBwN1NmS3NlQ3RtWU8=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDc0NDFTemZhN3E0SE0vTXI0OHFGNTRPZmdnNXpoQVU0amg0T1g2VHJIMDNlYk9TUmJLZFl1UnVGU2puVVE9PUk=" target="_blank" rel="external">航天测控技术的过去、现在和未来</a>、现在和未来[J]. 电讯技术,1999,02:3+5-10.</li>
<li><span id="2"> </span> <a href="www.nssc.cas.cn/xwzx/kydt/201307/W020130717344100734922.pdf">CSDS 概述 - 国家空间科学中心 - 中国科学院</a></li>
<li><span id="3"> </span> 刘嘉兴. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=0&amp;CurRec=1&amp;recid=&amp;filename=YHXB200506013&amp;dbname=CJFD2005&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;v=MzEzMjJYVGJMRzRIdFRNcVk5RVo0UjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTHlmYitScUZDdmdVYnZQUEM=" target="_blank" rel="external">载人航天USB测控系统及其关键技术</a>[J]. 宇航学报,2005,06:743-747.</li>
<li><span id="3"> </span> 饶启龙. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=12&amp;CurRec=1&amp;recid=&amp;filename=OXXT201103017&amp;dbname=CJFD2011&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;uid=WEEvREcwSlJHSldTTGJhYlRaSXVoREFFTWF3MEF2VFBwN1NmS3NlQ3RtWU8=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MjYyOTk4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUkx5ZmIrUnFGQ25oVjdyQktqWFRlckc0SDlETXJJOUVZNFI=" target="_blank" rel="external">航天测控技术及其发展方向</a>[J]. 信息通信技术,2011,03:77-83.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给marika感动得不要不要的]]></title>
      <url>http://bonewp.github.io.git/2016/08/20/%E7%BB%99marika%E6%84%9F%E5%8A%A8%E5%BE%97%E4%B8%8D%E8%A6%81%E4%B8%8D%E8%A6%81%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>之前伪恋看了一集就弃掉了，最近重新拾起来觉得这n角恋还挺好玩的，补了动画补漫画，结果进了marika线简直停不下来啊！我觉得marika简直是这里面塑造的最成功的角色了，人妻属性点满、逗逼属性点满，努力有觉悟。啊！~~~老夫的少女心…⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄…. (੭ु≧▽≦)੭ु</p>
<a id="more"></a>
<p>刚看动画的时候还只是觉得这孩子比较逗加上满满的套路就是了，到了逼婚线把背景都给交代清楚了才知道这尼玛绝对是后宫里最努力的人了啊。到逼婚这儿的时候简直感动得不要不要的 滚来滚去……~(～o￣▽￣)～o 。。。滚来滚去……o～(＿△＿o～) ~。。  </p>
<img src="/2016/08/20/给marika感动得不要不要的/marika.png" alt="marika.png" title="">  
<p>祝marika能找到自己的幸福，嗯！(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)</p>
<img src="/2016/08/20/给marika感动得不要不要的/marika.jpg" alt="marika.jpg" title="">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const限定符相关]]></title>
      <url>http://bonewp.github.io.git/2016/08/18/const%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>阅读const限定符一节的时候很是绕了点，发现这里很容易混淆，所以记录一下。</p>
<p>在需要定义变量的值不能被改变的时候，使用const加以限定，如<code>const int buffSize = 512;</code>这里是指变量本身是常量。</p>
<p>而在定义引用和指针的时候，注意是指<strong>引用或指针是指向常量的引用或指针</strong>，如<code>const int *p;</code>，这里指针p是<strong>指向常量的指针(pointer to const)</strong>， p指向的值必须是一个const类型，而p本身的值（即所存储的地址）则可以改变。这里一定要明确的概念就是<strong>指向常量的引用/指针不能用于改变其绑定/所指对象的值</strong>。</p>
<p>由于引用在初始化后不能再更改绑定对象，不用多说。而要让指针本身是常量的话，需要使用<code>*const</code>来定义<strong>常量指针(const pointer)</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;  <span class="comment">//p本身的值不能再改变，始终指向i</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">//pip是一个指向常量的常量指针</span></div></pre></td></tr></table></figure></p>
<p>由此可见，指针本身是常量和指向的对象是常量为两个独立问题。</p>
<blockquote>
<p>用名词<strong>顶层const(top-level const)</strong>表示指针本身为 常量，而用名词<strong>底层const(low-level const)</strong>表示指针所指的对象为一个常量。  </p>
</blockquote>
<p>顶层const可用于基本类型在内的任意对像，而底层const则与指针和引用等复合类型的基本类型部分有关。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[术语：何为对象]]></title>
      <url>http://bonewp.github.io.git/2016/08/17/%E6%9C%AF%E8%AF%AD%EF%BC%9A%E4%BD%95%E4%B8%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>最近腾出点时间复习C++，准备把C++ Primer好好看一遍。  </p>
<p>在<code>P39</code>上看到一个有趣的地方，什么是<strong>术语</strong>？书上给的解释是:  </p>
<blockquote>
<p>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p>
</blockquote>
<p>以前接触对象这个概念，总是基于面向对象之类的东西来说，一直感觉比较抽象。而这个从偏硬件的角度的解释，让我有一种豁然开朗的感觉，特别是在现在用FPGA用得多了之后。  </p>
<p>就像对FPGA代码最终要映射到FF、LUT等单元，对软件而言高级语言最终是要对应CPU对内存上的一段数据进行操作，这样刚才<strong>对象</strong>的解释也就能明白了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[verilog中的加法]]></title>
      <url>http://bonewp.github.io.git/2016/08/11/verilog%E4%B8%AD%E7%9A%84%E5%8A%A0%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这两天调一个项目的时候涉及到了符号数的加法和限幅，调了好久才发现这里面的坑。。瞬间觉得自己基础有待提高啊</p>
<h3 id="符号数的加法"><a href="#符号数的加法" class="headerlink" title="符号数的加法"></a>符号数的加法</h3><p>用补码来表示符号数，对两个符号数相加可以直接加法赋值，如下列代码，这是由补码的特性决定的，非常方便。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_1;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_2;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] add_ans;</div><div class="line"></div><div class="line">assign add_ans = sig_1 + sig_2;</div></pre></td></tr></table></figure></p>
<h3 id="加法溢出的处理"><a href="#加法溢出的处理" class="headerlink" title="加法溢出的处理"></a>加法溢出的处理</h3><p>然而固定位数的加法会出现溢出的问题，要为结果考虑进位，因此为结果多添加一位。此时一定要注意！</p>
<p><strong>符号数加法要进行符号位扩展！！</strong></p>
<p>当时没有注意到这个，死活不知道为什么结果的进位消失了…示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_1;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_2;</div><div class="line">wire [<span class="number">32</span>:<span class="number">0</span>] add_ans;</div><div class="line"></div><div class="line">assign add_ans = &#123;sig_1[<span class="number">31</span>], sig_1&#125; + &#123;sig_2[<span class="number">31</span>], sig_2&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="加法溢出限幅处理"><a href="#加法溢出限幅处理" class="headerlink" title="加法溢出限幅处理"></a>加法溢出限幅处理</h3><p>如果加法结果溢出了，但是要传至的信号位数是固定的，那么就需要限幅。</p>
<p>相对来说这个也很简单，这里占个坑，以后有需要再来填。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写markdown时用到的特殊用法]]></title>
      <url>http://bonewp.github.io.git/2016/08/09/%E5%86%99markdown%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>我在用Markdown写东西的时候，有时候用到了一些奇奇怪怪的用法，这里记录下来以便之后查阅。</p>
<h3 id="makedown通用语法相关"><a href="#makedown通用语法相关" class="headerlink" title="makedown通用语法相关"></a>makedown通用语法相关</h3><h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a><span id="sup/sub">上下标</span></h4><p>将需要修改为上下标的文字用html标签包裹即可。如下：<br>上标：<code>&lt;sup&gt; sup_text &lt;/sup&gt;</code><br>下标：<code>&lt;sub&gt; sup_text &lt;/sub&gt;</code></p>
<h4 id="文章内跳转"><a href="#文章内跳转" class="headerlink" title="文章内跳转"></a>文章内跳转</h4><p>将需要跳转至的地方加上html的id属性，形如：<code>&lt;span id=&quot;where_jump_to&quot;&gt; text &lt;/span&gt;</code><br>再在需要设置跳转的地方使用Markdown的链接语法，形如：<code>[text](#where_jump_to)</code></p>
<p>这里测试一下跳转至<a href="#sup/sub">上下标</a>。</p>
<a id="more"></a>
<h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>在断首加入<code>&amp;ensp;</code>输入一个空格；加入<code>&amp;emsp;</code>输入两个空格。</p>
<blockquote>
<p>&emsp;效果演示<br>效果演示  </p>
</blockquote>
<h3 id="框架使用相关"><a href="#框架使用相关" class="headerlink" title="框架使用相关"></a>框架使用相关</h3><h4 id="hexo相关"><a href="#hexo相关" class="headerlink" title="hexo相关"></a>hexo相关</h4><h5 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h5><p>我没有把图片存储到云盘上的习惯。。（好像暴露了什么），查阅到使用的hexo框架支持资源文件夹可以便捷的管理。</p>
<p>通过在站点配置文件<code>config.yml</code>中的<code>post_asset_folder</code>选项设为<code>true</code>后，可以将图片放在与文章同名的文件夹内，然后使用相对路径应用的标签插件来引用图片等资源，相较于常规的markdown语法<code>![](/image.jpg)</code>，可使图片在主页和存档页显示正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure>
<h5 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h5><p>在文章中使用<code>&lt;!-- more --&gt;</code>手动进行截断，Hexo 提供的方式。</p>
<h4 id="Next相关"><a href="#Next相关" class="headerlink" title="Next相关"></a>Next相关</h4><p>..</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vivado IO Constraint]]></title>
      <url>http://bonewp.github.io.git/2016/07/13/Vivado-IO-Constrain/</url>
      <content type="html"><![CDATA[<h2 id="IO-delay"><a href="#IO-delay" class="headerlink" title="IO delay"></a>IO delay</h2><h3 id="Input-delay"><a href="#Input-delay" class="headerlink" title="Input delay"></a>Input delay</h3><hr>
<p>数据相对于上升沿往后的延迟。<br><img src="/2016/07/13/Vivado-IO-Constrain/inputDelay_1.png" alt="inputDelay_1" title="inputDelay_1"><br><img src="/2016/07/13/Vivado-IO-Constrain/inputDelay_2.png" alt="inputDelay_2" title="inputDelay_2"><br>Example code:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create_clock -name sysClk -period <span class="number">10</span> [get_ports CLK0]</div><div class="line">set_input_delay -<span class="keyword">clock</span> sysClk -max <span class="number">4</span> [get_ports DIN]</div><div class="line">set_input_delay -<span class="keyword">clock</span> sysClk -min <span class="number">1</span> [get_ports DIN]</div></pre></td></tr></table></figure>
<p>若不考虑板级延迟，那就可根据前级芯片的建立/保持时间来推算此MAX/MIN的值。</p>
<a id="more"></a>
<h3 id="Output-delay"><a href="#Output-delay" class="headerlink" title="Output delay"></a>Output delay</h3><hr>
<p>数据相对于上升沿往前的延迟。即原点在目标时钟的上升沿，正半轴朝往前面的时间。<br><img src="/2016/07/13/Vivado-IO-Constrain/outputDelay_1.png" alt="outputDelay_1" title="outputDelay_1"><br>如果设定trce_dly都等于0的话（即板级延迟忽略），那么：</p>
<blockquote>
<p>The set_output_delay -max should be the setup requirement of the external device; The set_output_delay -min should be the negative of the hold requirement.</p>
</blockquote>
<p>Example code:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set_output_delay -<span class="keyword">clock</span> &lt;<span class="keyword">clock</span>&gt; <span class="number">0.6</span> [get_ports NWAIT]</div><div class="line">set_output_delay -<span class="keyword">clock</span> &lt;<span class="keyword">clock</span>&gt; <span class="number">-3.2</span> -min [get_ports NWAIT]</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://bonewp.github.io.git/2016/07/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
