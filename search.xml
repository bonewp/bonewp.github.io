<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JESD204b入坑]]></title>
      <url>http://bonewp.github.io.git/2017/04/27/JESD204b%E5%85%A5%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>正式入坑jesd204b。哦也…在此把一些阅读的基础内容做下记录  </p>
<h3 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h3><p>相较于AD/DA和FPGA之间的并行LVDS接口，jesd204使用帧串行数据链路及嵌入式时钟和对齐字符，所需引脚数大量减少(那一天，我又想起了画板布线时被几十组并行LVDS信号支配的恐惧…)。<br>而jesd204b是该规范的第三个版本，特点是可知链路上串行数据的确定延迟，这对有相参性要求（固定延迟）的设计来说尤为重要。  </p>
<p>204b定义了三种设备子类，包括子类0、1、2，其中子类1主要针对工作在500MSPS及以上的转换器，目前大多数AD/DA也是采用class 1。接下来也主要针对class 1做学习。    </p>
<img src="/2017/04/27/JESD204b入坑/jsed204规范与LVDS规范比较.png" alt="jsed204规范与LVDS规范比较.png" title="">  
<a id="more"></a>
<p>204b支持的每通道(Lane)串行链路速率最高为12.5Gbps，支持多通道(Multiple Lanes)、多通道同步、多器件同步和确定性延迟。比起传统的LVDS最高1Gbps通道速率来说，优点是非常明显(当然复杂太多了)。  </p>
<p>简要明确一些概念，204b通过三个阶段来建立同步链路：代码组同步(code group synchronization, CGS)，初始化通道同步(initial lane synchronization, ILAS)，数据传输阶段(data transmission phase)。后续详细记录每个阶段在做什么。<br>链路中的关键信号：共享参考时钟(器件时钟，由一个时钟源提供至AD/DA/FPGA)， 差分CML物理连接(即通道lane)，其他同步信号(SYNC~和可能的SYSREF)。其中SYSREF是子类1中用于建立确定性延迟。  </p>
<h4 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h4><p>对于链路的建立，某些变量需要注意：<br>M：转换器数量(number of converters)<br>L：物理通道数(number of physical lanes)<br>F：每帧的8位字数(number of octets per frame)<br>K：每个多帧的帧数(number of frames per multiframe)<br>N和$N^{‘}$：分别表示转换器分辨率和每个样本使用的位数(4的倍数)。$N^{‘}=N+$控制和伪数据位数(结束位或控制位)。<br>S：每个转换器每帧发送的样本数。通常设为1，使转换器帧时钟(FC)和采样时钟相等。   </p>
<h4 id="确定性延迟"><a href="#确定性延迟" class="headerlink" title="确定性延迟"></a>确定性延迟</h4><p>MS-2503中提到确定性延迟的概念  </p>
<blockquote>
<p>JESD204B链路的确定延迟定义为数据从发送器(ADC或源端FPGA)的并行帧数据输入传播至接收器(DAC或接收端FPGA)并行去帧数据输出所需的时间。该时间通常以分辨率为帧时钟周期或以器件时钟进行测量。该定义不包括ADC的模拟前端内核或DAC的后端模拟内核。  </p>
</blockquote>
<p>所以204B的确定延迟是区别于ADC/DAC的总延迟的，后者是从输入一个模拟样本至从器件输出数字信号的时间。   </p>
<p>MS-2672中提到  </p>
<blockquote>
<p>JESD204B标准把确定性延迟(deterministic latency, DL)定义为基于帧的样本到达串行发射器与串行接收器输出基于帧的样本的时间差。延迟在帧时钟域中测量，必须能以至少相当于帧时钟周期的增量编程。在上电周期之间，以及任何再同步事件中，延迟必须可重复。<br>JESD204系统中的确定性延迟由固定延迟和可变延迟构成。可变延迟是由数字处理模块中时钟域之间在供电周期间存在任意性的相位关系所导致。 JESD204A和JESD204B子类0系统中，无法处理可变延迟。因此，整个链路的延迟存在供电周期变化。  </p>
</blockquote>
<img src="/2017/04/27/JESD204b入坑/确定性延迟图示.png" alt="确定性延迟图示.png" title="">  
<p>所以子类1引入的外部参考信号SYSREF，为采样时序提供系统级参考，用于实现确定性延迟。其概念如下图，子类1系统中定义了一个“接收缓冲器(receive buffer)”，其释放时间以外部SYSREF信号为基准，由此解决供电周期变化导致的不确定性延迟。这个receive buffer我觉得就是个fifo，使能信号由SYSREF经过一些逻辑决定。   </p>
<img src="/2017/04/27/JESD204b入坑/子类1系统使用SYSREF的数据释放图示.png" alt="子类1系统使用SYSREF的数据释放图示.png" title="">  
<p>这里还提到了SYSREF和器件时钟应从相同器件生成，以确保两个信号相位对齐。SYSREF周期必须为LMFC(Local multiframe clock)的的整数倍，建议用提供整个系统器件时钟的统一器件来生产SYSREF信号。并且每一个器件的SYSREF和DCLK走线等长，使得SYSREF满足时序要求，保证能在SYSREF跳变后的第一个DCLK上升沿采到SYSREF有效值，以减小确定性延迟不确定性(deterministic latency uncertainty, DLU)。   </p>
<p>上面的内容是从Survival-Guide中阅读的， 感觉一开始就看这种感觉有点稀里糊涂的。  </p>
<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>JESD204B接口协议标准是一种分层规范，如下图所示，可分为四层：应用层，传输层，数据链路层，物理层。<br><img src="/2017/04/27/JESD204b入坑/jesd204b层次结构.png" alt="jesd204b层次结构.png" title="">    </p>
<p>应用层：用于支持204B链路的配置和数据映射。   </p>
<p>传输层：实现转换样本与成帧未加扰八位字之间的映射。即组帧，这与特定的转换器配置及样本与帧之间的映射方式强相关，需要用户根据选定器件自行编写实现。  </p>
<p>数据链路层：处理链路的同步、建立与保持，及8/10b编解码，另有可选的加解扰。该层产生或检测控制字符，用于监测和维护通道对齐。  </p>
<p>物理层：串行器/解串器(SERDES)，以通道(Lane)比特速率发送/接收编码后的字符。包括有串行器、驱动器、接收器、时钟和数据恢复电路。  </p>
<p>具体结合帧的产生图示如下，可以清楚地看到样本(sample)变为8/10b串行字的过程。<br><img src="/2017/04/27/JESD204b入坑/jesd204b链路图.png" alt="jesd204b链路图.png" title="">    </p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><blockquote>
<p>通过应用层实现特殊用户配置，以及将采样数据映射道典型204B规范之外。<br>必须注意：发送器(ADC)和接收器(FPGA)均须采用此类特殊配置。  </p>
</blockquote>
<p>我理解就是添加用户自定义的204b中没有的一些配置进去，比如说将样本重新打包等等，这个不做深入，当有需要时自己添加逻辑就是了。  </p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层的目的是将样本转换成8位字，并组成一帧。  </p>
<img src="/2017/04/27/JESD204b入坑/jesd204b链路图.png" alt="jesd204b链路图.png" title="">    
<p>结合上图， [MS-2714]中的介绍是：  </p>
<blockquote>
<p>传输层接受ADC样本并添加信息(填充)以产生半字节组(通常在4位边界上)。此信息以结束位或控制位的形式提供，是有关所传输数据的附加信息。传输层将这些半字节组安排为帧。</p>
</blockquote>
<p>这里半字节组的意义，我认为是样本数据的最小单位，对应了N’为4的倍数，以该最小单位组成8位字，比如N’=12时，一个样本(204B字)不能组成整数个8位字，需要多个样本才行。   </p>
<p>换句话说，先对样本添加控制字组成了N’宽度的204B字，再对其分为半字节组，然后将多个半字节组组成8位字，最后形成帧。(图中加结束位我觉得有点问题)  </p>
<p>有点绕，反正就是对样本添加控制/结束位以8位字为单位组为帧。半字节组先不管我觉得也可以。     </p>
<p>需要注意的是：  </p>
<blockquote>
<p>传输层以并行数据将这些样本提供给数据链路。并行数据总线的宽度由成帧器结构决定，单字节为8位，双字节为16位，以此类推。  </p>
</blockquote>
<p>也就是说这些并行数据宽度与一帧数据的宽度是一致的。而每帧的8位字数量的计算公式是F=(M<em>S</em>N’)/(8<em>L)，这个公式很容易理解，不多说。<br>有一点，L是根据采样率和N’结合最大通道(lane)速率决定的，如500MSPS，N’=16，S=1，则单转换器的通道速率=500M</em>16*10/8=10Gbps&lt;12.5Gbps，那么可设L=1。     </p>
<p>另外，传输层根据给定器件已定义的链路配置参数，决定如何包装来自ADC的数据。这些参数在ILAS期间从ADC传输到FPGA，而参数是通过SPI配置的，其设置ADC和FPGA上的寄存器来定义链路配置参数。但是  </p>
<blockquote>
<p>通过链路传输的这些参数不是用于配置接收器，而是仅用于验证链路参数匹配。  </p>
</blockquote>
<p>这也有点绕，总之就是先有了SPI配置链路参数，再有在链路传输这些参数用于验证，检测到错误则FPGA报告错误。   </p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><blockquote>
<p>数据链路层接收并行成帧数据(包含ADC样本、控制位和结束位)，并输出8/10b字，后者在物理层中进行串行化且可以加扰。  </p>
</blockquote>
<p>在这一层通过三个阶段建立同步链路。（加解扰我暂时没有关注）    </p>
<p>1.代码组同步(CGS)阶段  </p>
<blockquote>
<p>各接收器(FPGA)必须利用时钟和数据恢复(CDR)技术，在ADC传来的输入数据流中找到K28.5字符。一旦在所有链路通道上检测到某一数量的连续K28.5字符，接收器模块就会解除置位至发送器模块的SYNC~信号。<br>在JESD204B中，发送模块捕捉SYNC~信号的变化，并在下一个本地多帧时钟(LMFC)边界上启动ILAS。  </p>
</blockquote>
<p>2.初始通道同步(ILAS)阶段  </p>
<blockquote>
<p>ILAS的主要作用是对齐链路的所有通道，验证链路参数，以及确定帧和多帧边界在接收器的输入数据流中的位置。   </p>
</blockquote>
<p>ILAS一般由4个多帧组成，如下图所示<br><img src="/2017/04/27/JESD204b入坑/ILAS阶段多帧.png" alt="ILAS阶段多帧.png" title="">    </p>
<p>其中控制字符的含义如下所示，注意第二针/Q/字符之后的数据是链路配置参数，这个我觉得应该是去查具体使用的芯片手册。其他填充的数据为伪数据。<br><img src="/2017/04/27/JESD204b入坑/jesd204控制字符.png" alt="jesd204控制字符.png" title="">    </p>
<p>3.用户数据阶段  </p>
<blockquote>
<p>在这一阶段，用户数据根据发送器(ADC)中定义并转发到接收器(FPGA)的链路参数，以流形式从发送器传输到接收器。<br>接收器模块处理并监视收到的数据有无错误，包括运行差异不正确(8B/10B错误)、不在表中(8B/10B错误)、意外控制字符、 ILAS不正确和通道间偏斜。  </p>
</blockquote>
<p>如果接收器检测到了错误，将会通过SYNC~报告错误。  </p>
<p>另外在用户数据阶段，还可通过数据链路中的字符替换来监视并纠正帧和通道对齐。字符替换发生帧或者多帧边界，这个我觉得也去查具体使用芯片来使用。  </p>
<p>将上述三个阶段总结下来如下图所示<br><img src="/2017/04/27/JESD204b入坑/数据链路层序列.png" alt="数据链路层序列.png" title="">    </p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><blockquote>
<p>在物理层中，数据进行串行化， 8B/10B编码数据以线路速率发送和接收。  </p>
</blockquote>
<p>在Xilinx FPGA中通过PHY IP核实现，除开电路板设计的因素，应该没什么需要注意的了。   </p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="http://www.analog.com/media/en/technical-documentation/technical-articles/JESD204B-Survival-Guide.pdf" target="_blank" rel="external">JESD204B-Survival-Guide</a><br><a href="http://www.analog.com/media/cn/technical-documentation/technical-articles/MS-2714_cn.pdf" target="_blank" rel="external">了解JESD204B规范的各层_从高速ADC的角度出发</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FWFT模式fifo的使用细节]]></title>
      <url>http://bonewp.github.io.git/2017/04/26/FWFT%E6%A8%A1%E5%BC%8Ffifo%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</url>
      <content type="html"><![CDATA[<p>这两天使用fifo generator的时候，对First-Word Fall-Through(FWFT)模式详细看了下，发现了一点有趣的细节。  </p>
<p>首先知道FWFT模式相对于Standard模式不同的是，不需要读命令，fifo自动将最新的数据放在dout上，这样对fifo读出的使能和数据能做到同步，控制更简单一些。从时序图上能很容易地明白。  </p>
<img src="/2017/04/26/FWFT模式fifo的使用细节/standard_fifo_read.png" alt="standard_fifo_read.png" title="">  
<img src="/2017/04/26/FWFT模式fifo的使用细节/FWFT_fifo_read.png" alt="FWFT_fifo_read.png" title="">  
<p>而特别的地方就在于如何实现提前将数据放在rd_dout上，查看datasheet发现是这么说的  </p>
<blockquote>
<p>By providing the capability to read the next data word before requesting it, first-word fall-through (FWFT) implementations increase the depth of the FIFO by 2 read words.  </p>
</blockquote>
<a id="more"></a>
<p>也就是多存了两个数据在里面，从Data Count也能看出来这一点。<br>那么当写入多少个数据时，读出接口的empty才会deasserted？  </p>
<p>我仿了下IP核，用的非对称数据宽度和不同写入读出时钟，发现结果如下：  </p>
<img src="/2017/04/26/FWFT模式fifo的使用细节/FWFT_fifo_empty.png" alt="FWFT_fifo_empty.png" title="">  
<p>也就是说要写入两个数据时，empty信号才会deasserted，而且在这时立即读出的话，rd_dout不会更新，那么第二个写入的数据不会呈现出来。<br>这在连续读写时当然不会有问题，但在突发读写且会读空fifo的情况下，写入逻辑就需要稍微注意下，要多塞几个数进去才能将有效数据全部给拿出来，而具体多塞几个就看具体情况去控制了。  </p>
<p>另外wr/rd_count也是个有趣的东西，在不同模式和不同读写宽度比例时其初始值不同。对其介绍Product Guide是这么说的  </p>
<blockquote>
<p>For FWFT implementations using More Accurate Data Counts (Use Extra Logic), data_count is guaranteed to be accurate when words are present in the FIFO, with the exception of when its near empty or almost empty or when initial writes occur on an empty FIFO. In these scenarios, data_count may be incorrect on up to two words.  </p>
</blockquote>
<p>在接近empty的时候rd_count是错的… 那要你来何用… 看了下前面的介绍，多是拿来判断fifo半空，四分之一空等，不过我暂没这么用过就是了。<br>反正用这个rd_count的时候也是要注意才行。  </p>
<p>参考<br><a href="https://www.xilinx.com/products/intellectual-property/fifo_generator.html" target="_blank" rel="external">PG057</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[7Series DDR3的使用]]></title>
      <url>http://bonewp.github.io.git/2017/04/16/7Series-DDR3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="背景了解"><a href="#背景了解" class="headerlink" title="背景了解"></a>背景了解</h3><p>在知乎上看见的专栏写得挺清楚的<br><a href="https://zhuanlan.zhihu.com/p/26255460" target="_blank" rel="external">内存系列一：快速读懂内存条标签</a><br><a href="https://zhuanlan.zhihu.com/p/26327347" target="_blank" rel="external">内存系列二：深入理解硬件原理</a>  </p>
<p>需要注意的是，层级关系是channel＞DIMM＞rank＞chip＞bank＞row/column，是由多个chip组成了一个rank，每个chip数据宽度8bit，那么64bit数据宽度由8个chip级联组成，每个chip再划分为bank，往下就是最小单位rou/colum，具体可参考<a href="http://www.techbang.com/posts/18381-from-the-channel-to-address-computer-main-memory-structures-to-understand" target="_blank" rel="external">图解RAM结构与原理</a>。  </p>
<h3 id="存储器接口"><a href="#存储器接口" class="headerlink" title="存储器接口"></a>存储器接口</h3><p>Xilinx 7Series FPGA的存储器接口示意图如下：<br><img src="/2017/04/16/7Series-DDR3的使用/7系列FPGA存储接口.png" alt="7系列FPGA存储接口.png" title="">  </p>
<p>详细的接口定义在UG586_P92。  </p>
<a id="more"></a>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>用户接口包括了命令路径、写路径和读路径等，每条路径的信号定义套路好像差不多。  </p>
<h4 id="Command-Path"><a href="#Command-Path" class="headerlink" title="Command Path"></a>Command Path</h4><p>命令路径包括app_en，app_addr和app_cmd。<br>在每个app_en和app_rdy有效的时钟上升沿，产生一次app_cmd对应的有效命令。<br>app_cmd=0为写入命令，1为读出命令。<br>app_addr为用户地址，按照设定的映射关系对应至RANK、BANK、ROW和COL，每一个地址对应的数据大小等于ddr_dq位宽，即DDRSRAM的数据位宽。因此在BL8读写时，每次读写时地址值应该加8。    </p>
<p>其时序如下图。注意若app_rdy没有置位，app_en &amp; addr &amp; cmd需要保持直到app_rdy有效。<br><img src="/2017/04/16/7Series-DDR3的使用/命令路径时序_app_rdy.png" alt="命令路径时序_app_rdy.png" title="">  </p>
<h4 id="Write-Path"><a href="#Write-Path" class="headerlink" title="Write Path"></a>Write Path</h4><p>写入路径是一个写入fifo接口，且该接口时序不需要和命令路径完全对齐，写入数据可以超前于命令，也可以滞后于命令。唯一条件是对于每个app_cmd写命令，要有相关的app_wdf_data数据呈现。<br>需要注意数据滞后于命令时最大延迟为2个时钟。另外app_wdf_en和app_wdf_rdy的处理方式和命令路径套路一样。    </p>
<p>非背靠背写入数据时序如下图：<br><img src="/2017/04/16/7Series-DDR3的使用/写入路径时序.png" alt="写入路径时序.png" title="">  </p>
<p>datasheet还给出了突发模式写入的示意图，下图是突发长度8(BL8，即连续写8个地址的数据)的传输，2:1的PHY to Memory Controller clk比例，8bit存储器数据宽度。<br><img src="/2017/04/16/7Series-DDR3的使用/突发写路径时序.png" alt="突发写路径时序.png" title="">  </p>
<p>首先计算一下，UI数据宽度=8<em>2</em>2=32bit，即突发长度为4，要实现BL8则需要两个时钟的数据。<br>从图中可以看到，app_wdf_end(used to indicate the end of a memory write burst)在第二个app_wdf_data有效，即每次突发写对应两个数据长度，与刚才的计算结果一致。<br>app_en和app_rdy有效长度四个时钟，且app_cmd=0，即有这样相同的4条写指令。app_addr递增的值8与突发写长度8一致。<br>注意最后一个写指令(app_addr=0000418)与数据app_wdf_data刚好相差两个时钟，满足时序要求。  </p>
<p><strong>注意</strong> datasheet中明确说明了Burst Lenth仅支持LB8，即在4:1模式下，一个写入指令对应一次BL8写，那么app_wdf_end信号与app_wdf_en信号应该是同时有效的。<br>开始仿真的时候没有注意到这个点，以为一次写入指令可以写不限长度的数据进去，费了我好多时间啊…   </p>
<h4 id="Read-Path"><a href="#Read-Path" class="headerlink" title="Read Path"></a>Read Path</h4><p>读路径的时序如下图，只需在app_rdy有效和app_en置位时，将app_addr连续的呈出即可。<br><img src="/2017/04/16/7Series-DDR3的使用/读路径时序.png" alt="读路径时序.png" title="">  </p>
<p>UI接口中还有app_rd_data_end，在用户逻辑中不需要使用。  </p>
<p>仿真的时候发现一个细节，除了app_rd_data_valid上升沿的位置，app_rd_data的变化沿相对时钟上升沿有延迟，大约为0.1ns，我因为在比较读出数据时使用了组合逻辑发现了这个细节，所以对读出数据操作时要使用时序逻辑。  </p>
<h3 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h3><p>首先写了一个粗糙的仿真验证控制时序，没有采用fifo传递数据给DDR_UI，而是直接传递了一些自定义参数在内部生成的数据，当然实际上不应该这样做，这里只是仿一下时序。正常使用时应该用fifo传递并转换数据宽度。    </p>
<p>为了减少控制的麻烦，写路径将app_wdf_wren与app_cmd直接绑定在了一起，也就是写数据始终与写命令同步。<br>从仿真图中可以看到，app_rdy会出现长段的无效状态，它对连续读写时的控制很重要。<br>我采取的方法是将app_rdy和app_wdf_rdy一起作为cmd_valid信号控制写操作，当cmd_valid无效时保持当前值直至其有效。<br>下图是写时序的仿真结果。<br><img src="/2017/04/16/7Series-DDR3的使用/仿真写时序.png" alt="仿真写时序.png" title="">    </p>
<p>下图是连续写的仿真结果。<br>从仿真结果可以看到app_rdy会呈周期性地出现无效状态，这应该是DDRSRAM进行刷新等操作带来的，由此影响了写入的效率继而影响连续写入速度。下一步上板实际测试写入速度。<br><img src="/2017/04/16/7Series-DDR3的使用/仿真写_1024次.png" alt="仿真写_1024次.png" title="">    </p>
<p>读路径的控制时序则分为两部分，首先是写入命令，然后是接收数据，这之间有一段延时。<br>下图是读时序仿真结果。与之前写入的值是一致的，说明仿真正确。<br><img src="/2017/04/16/7Series-DDR3的使用/仿真读_1.png" alt="仿真读_1.png" title="">    </p>
<img src="/2017/04/16/7Series-DDR3的使用/仿真读_2.png" alt="仿真读_2.png" title="">    
<p>（读仿真写入命令时，app_addr在app_en无效后还递增了一个值，反正不影响，我就没改了… ）</p>
<p>下图是连续读的仿真结果。<br>app_rdy无效状态的出现与写入时差不多，需要注意在未完全读结束之前app_rd_data_valid也会出现无效状态，因此用户需要在读出时自行计数读出的深度。<br><img src="/2017/04/16/7Series-DDR3的使用/仿真读_1024次.png" alt="仿真读_1024次.png" title="">    </p>
<h3 id="上板测试"><a href="#上板测试" class="headerlink" title="上板测试"></a>上板测试</h3><p>使用Xilinx的KC705开发板测试，板卡上的SODIMM大小为1GB，对应用户地址app_addr宽度27bit（每一个地址对应64bit数据），即地址范围0x000_0000~0x7ff_ffff。<br>工作参数：用户时钟ui_clk 200MHz；DDR工作时钟800MHz；数据位宽64bit。  </p>
<p>分别测试写入和读出消耗的时钟周期，测试结果如下图：<br><img src="/2017/04/16/7Series-DDR3的使用/板卡测试写结果.png" alt="板卡测试写结果.png" title="">    </p>
<img src="/2017/04/16/7Series-DDR3的使用/板卡测试读结果.png" alt="板卡测试读结果.png" title="">    
<p>由此可以计算实际大致的写入速度 = 800M * 2 * 64bit / 1.17 = 1600M * 8Byte / 1.17 = 10940MB/s，大约10GB/s的速度，感觉好厉害的样子…<br>同样的读出速度 = 1600M * 8Byte / 1.1 = 11636MB/s， 大约11GB/s，比写入速度快一些。  </p>
<p>不过我想这个读写速度与存储颗粒/条本身的质量关系很大，这个测试数据也就做个参考，之后在项目中用反正是妥妥地速度够用了。  </p>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>在使用vivado生成DDR IP核的时候，遇到了兼容性问题，生成IP核程序会不定期地卡死，每次打开都是小心翼翼地修改，感觉就是拼运气。而且在导入管脚定义一步时只要一点导入IP核就会跪掉，也是无语…<br>在网上搜寻一番，有人认为是win10兼容性问题，win7下不会有该问题，但是我没去虚拟机下测试了，直接用example design中生成好的IP拿来用。   </p>
<p>但是在官方示例工程基础上写好了测试模块后，上板测试时发现初始化校验不能通过，init_calib_complete信号始终没有拉高。检查了IP核设置和约束等，没有发现任何可能的问题，最终移植了一个老师以前调试好的工程中IP核就可以正常通过了，但还是没发现设置或约束上不同的地方，只能当做遗留问题处理了，以后再开发的时候也就直接移植过来用…  </p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.xilinx.com/products/intellectual-property/mig.html#documentation" target="_blank" rel="external">UG-586-Zynq-7000 All Programmable SoC and 7 Series Devices Memory Interface Solutions v4.2 User Guide</a>  接口相关的在Ch1-Interfacing to the Core-User Interface  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分段卷积]]></title>
      <url>http://bonewp.github.io.git/2017/04/10/%E5%88%86%E6%AE%B5%E5%8D%B7%E7%A7%AF/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在长序列与短序列进行卷积时(特别是输入序列变长或无限长)， 常采用分段卷积的方法处理。即将长序列分段为多个子段，对每个子段分别计算线性卷积后，再将每段计算输出按照一定的关系组合在一起，即可得到与原序列计算卷积相同的结果。  </p>
<p>这样可降低运算量并提高实时性，特别是对子段的计算采用FFT方法，进一步提高速度。<br>开始提到分段卷积应用于两序列的长度相差较大时，而对于何时用分段卷积何时用FFT计算，<a href="https://zh.wikipedia.org/wiki/卷积" target="_blank" rel="external">维基</a>上有详细比较的示例。  </p>
<p>而分段卷积根据方式不同，有重叠相加法和重叠保留法两种，我在一篇文章中看到过介绍说，两种方法的计算效率相同，所以要实际应用时分情况选择。  </p>
<a id="more"></a>
<h3 id="重叠相加法"><a href="#重叠相加法" class="headerlink" title="重叠相加法"></a>重叠相加法</h3><p>假设x[n]长度为N，h[n]长度为M，则x[n]*h[n]长度为N+M-1。<br>将x[n]分为k个子段，每个子段长度为L，即$x_k[n]=x[n]$，其中$kL \leq n \leq (k+1)L-1$，即每个子段相互之间无重叠。  </p>
<p>计算$y_k[n] = x_k[n] * h[n]$$后，对各$y_k[n]$重叠相加后即可得到y[n]。而重叠相加的关系如下：$y_k[n]$长度为L+M-1，其中$y<em>k[n]$的后M-1个点与紧邻下一子段$y</em>{k+1}[n]$的前M+1个点相互重叠，因此每次计算出一个$y<em>k[n]$后，与$y</em>{k-1}[n]$按刚才的关系叠加后，可得到前L个点为最终实际输出，而后M-1个点还需用于下一次计算。<br>可知每次子段计算有效输入输出L点。    </p>
<p>刚才的关系按照冲击响应法去画图很容易理解，并且注意，每个子段卷积计算结果为L+M-1点，即可用L+M-1点FFT对应的循环卷积得到线性卷积结果。  </p>
<h3 id="重叠保留法"><a href="#重叠保留法" class="headerlink" title="重叠保留法"></a>重叠保留法</h3><p>假设x[n]长度为N，h[n]长度为M，则x[n]*h[n]长度为N+M-1。<br>将x[n]按重叠分段分成k个子段，每个子段的前M-1点与上一子段的后M-1点相同，即$x_k[n] = x[n+k(L-M+1)]$，其中$0 \leq n \leq L-1$。  </p>
<p>需要注意必须满足子段的长度$M \leq L$，并且$x_k[n]$与h[n]采用的是L点循环卷积。这样循环卷积的结果$y_k[n]$为L点，而原线性卷积的长度为L+M-1，分析可知$y_k[n]$前M-1点是混叠的应该舍去，而后L-M+1点无混叠为实际输出。  </p>
<p>因此每次做L点循环卷积后，取后L-M+1点作为实际输出，即每次子段计算有效输入输出L+M-1点。  </p>
<p>实际运算时常采用50%重叠，即取L=2M做L点循环卷积(用FFT实现)。并且对序列开头补0以得到线性卷积输出。    </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>上述方法目的都是为了减少计算量，而我在实际运用时遇到的场景是，输入序列不定长，需要分段，而h[n]不定长的同时长度很常，一次性长序列的FFT计算带来的延迟过大，因此我也想对h[n]分段。<br>这个时候就需要将输入x[n]分割为长度小于h[n]的子段，再在$x_k[n]$子段计算时将h[n]分子段计算。  </p>
<p>重叠保留法要求子段长度满足$M \leq L$，因此对x[n]分段时不可取，我验证了下重叠相加法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">x = randi(10,1,1024);</div><div class="line">h = randi(10,1,2048);</div><div class="line"></div><div class="line">L=length(x);</div><div class="line">M=length(h);</div><div class="line">k = 4;          %分段数量</div><div class="line">Nseg= L/k;      %每段长度</div><div class="line"></div><div class="line">x = [x, zeros(1,k*Nseg-L)];</div><div class="line">y = zeros(1, L+M-1);</div><div class="line"></div><div class="line">for i=0:1:k-1</div><div class="line">    ix = i*Nseg;</div><div class="line">    xseg = x(ix+1 : ix+Nseg);</div><div class="line">    yseg = cconv(xseg, h, Nseg+M-1);    %DFT对应的循环卷积实现线性卷积</div><div class="line">%     yseg = conv(xseg, h);</div><div class="line">    y(ix+1:ix+Nseg+M-1)=y(ix+1:ix+Nseg+M-1)+yseg(1:Nseg+M-1);</div><div class="line">end</div><div class="line"></div><div class="line">yori = conv(x,h);   %原线性卷积序列</div></pre></td></tr></table></figure>
<p>比较y和yori结果相同，也就是说重叠相加法对子段长度L和卷积序列长度M之间的关系大小要求。  </p>
<p>因此可采取的方法举例，将输入序列按照重叠相加分段为512点子段，子段与4096点h[n]做线性卷积后的输出结果按照重叠关系相加后得到实际输出序列。<br>而h[n]按照重叠保留法（也可重叠相加法）分为1024点子段，做1024点循环卷积，取后512点为线性卷积结果。<br>这样FFT计算单位定为了1024点，当然这样是以资源换取速度的策略。而且各子段结果之间的衔接也是很重要的一点。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雷达扩展目标回波信号的仿真]]></title>
      <url>http://bonewp.github.io.git/2017/03/30/%E9%9B%B7%E8%BE%BE%E6%89%A9%E5%B1%95%E7%9B%AE%E6%A0%87%E5%9B%9E%E6%B3%A2%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BB%BF%E7%9C%9F/</url>
      <content type="html"><![CDATA[<h3 id="单点目标"><a href="#单点目标" class="headerlink" title="单点目标"></a>单点目标</h3><h3 id="单点目标的时移"><a href="#单点目标的时移" class="headerlink" title="单点目标的时移"></a>单点目标的时移</h3><h3 id="两点目标"><a href="#两点目标" class="headerlink" title="两点目标"></a>两点目标</h3><h3 id="多点目标"><a href="#多点目标" class="headerlink" title="多点目标"></a>多点目标</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雷达扩展目标回波信号]]></title>
      <url>http://bonewp.github.io.git/2017/03/29/%E9%9B%B7%E8%BE%BE%E6%89%A9%E5%B1%95%E7%9B%AE%E6%A0%87%E5%9B%9E%E6%B3%A2%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>通过雷达分辨单元与雷达目标尺寸比较，将雷达目标区分为：<br>若目标尺寸远小于雷达分辨单元，视为点目标处理；若目标尺寸远大于雷达分辨单元，视为扩展目标处理。  </p>
<p>例如使用LFM波形，设基带带宽为100MHz，则距离分辨率为$\delta_r = c/2B = 1.5m$，远大于该尺寸的目标应视为扩展目标。  </p>
<p>对于点目标来说，其数学模型由雷达散射截面(RCS)描述；而对于扩展目标而言，需要结合散射中心的理论进行建模。参考论文中的描述是：  </p>
<blockquote>
<p>扩展目标的电磁散射场可认为是各个散射中心的散射场叠加形成的，其电磁散射特性可以认为由其若干个散射中心共同作用的结果。<br>此时只需要将扩展目标的各个散射点在自身散射特性的基础上进行矢量叠加便可得到整个扩展目标的散射特性描述。  </p>
</blockquote>
<a id="more"></a>
<p>基于上述结论，可以先建立单个散射点的回波模型，再做矢量叠加得到扩展目标的回波模型。  </p>
<p>另一方面，将目标视作一个线性时不变系统(LTI)，由冲击响应来表征目标，则目标回波是雷达发射信号经过一个LTI系统后的信号输出。<br>即目标回波信号表示为$s_r(t)=s(t) * h(t)$。  </p>
<p>所以可以先计算单散射点回波模型的冲击响应函数，进而得到扩展目标的冲击响应。  </p>
<h3 id="单点目标回波模型"><a href="#单点目标回波模型" class="headerlink" title="单点目标回波模型"></a>单点目标回波模型</h3><p>设采用线性调频信号<br>$s(t) = rect(t/t_p)e^{j(\omega_c t+\pi \gamma t^2)}$<br>其中$\omega_c$为发射信号中心频率，$t_p$为脉冲宽度，$\gamma$为线性调频斜率，且$B=\gamma t_p$。  </p>
<p>假设目标初始径向距离为$R_0$，匀速径向速度为$\nu$，目标靠近雷达运动，则回波延时为<br>$\tau = \frac{2(R_0-\nu t)}{c}$  </p>
<p>用PRT上升沿击中目标时目标的回波延时代替整个脉冲内的回波延时，则第n个PRT击中目标时的快时间$\tilde{t}$（以第n个PRT为参考的时间）满足：<br>$R<em>0 - \nu((n-1)\cdot t</em>{PRT}+\tilde{t}) = c\cdot \tilde{t}$  </p>
<p>那么$\tilde{t} = \frac{R<em>0 - \nu \cdot (n-1)\cdot t</em>{PRT}}{c-\nu}$  </p>
<p>此时目标的回波延时为<br>$\tau_1 = 2 \tilde{t} \approx \frac{2(R<em>0 - \nu \cdot (n-1)\cdot t</em>{PRT})}{c}$  </p>
<p>目标回波信号表示为发射信号的延时<br>$s_r(t) = As(t-\tau) = A rect(\frac{t-\tau}{t_p}) exp({j(\omega_c (t-\tau)+\pi \gamma (t-\tau)^2)})$<br>其中A为回波信号幅度，将$\tau$替换为$\tau_1$近似为第n个PRT的信号回波。</p>
<p>为了模拟该回波，需要将雷达发射信号搬移至中频(基带)做卷积， 因此先得到回波信号的中频形式，设中频频率为$\omega<em>l$，且$\omega</em>{\Delta} = \omega_c - \omega_l$。(当 $\omega<em>l = 0$ 时为基带形式)则中频回波信号为<br>$s</em>{rl}(t) = s<em>r(t) * exp(-j\omega</em>{\Delta})$<br>$= A rect(\frac{t-\tau_1}{t<em>p}) exp(-j\omega</em>{\Delta}\tau_1) exp({j(\omega_l (t-\tau_1)+\pi \gamma (t-\tau_1)^2)})$<br>$= s<em>l(t) * [A exp((-j\omega</em>{\Delta}\tau_1)) \delta(t-\tau_1)]$<br>其中$s_l(t)$为雷达中频发射信号。  </p>
<p>由此得到中频形式的冲激响应函数为<br>$h<em>l(t) = A exp((-j\omega</em>{\Delta}\tau_1)) \delta(t-\tau_1)$  </p>
<p>该冲激函数包含了点目标回波的延迟、幅度和相位信息。<br><strong>疑问：这个相位信息的物理意义是？</strong>  </p>
<h3 id="扩展点回波"><a href="#扩展点回波" class="headerlink" title="扩展点回波"></a>扩展点回波</h3><p>已知扩展点目标为目标上的所有散射点回波的矢量和，则N扩展点的总目标回波为<br>$s<em>{r1\sum}(t) = \sum</em>{i=1}^N s_l(t) <em> [A<em>i exp((-j\omega</em>{\Delta}\tau<em>{i1})) \delta(t-\tau</em>{i1})]$<br>$= s_l(t) </em> \sum_{i=1}^N[A<em>i exp((-j\omega</em>{\Delta}\tau<em>{i1})) \delta(t-\tau</em>{i1})]$<br>其中$A<em>i$是第i个散射点的回波信号幅度，$\tau</em>{i1}$是第i个散射点的回波时延。  </p>
<p>所以扩展目标的冲击响应函数为<br>$h<em>l(t) = \sum</em>{i=1}^N [A<em>i exp(-j \omega</em>{\Delta} \tau<em>{i1}) \delta(t-\tau</em>{i1})]$  </p>
<p>参考文献的结论：  </p>
<blockquote>
<p>目标的散射特性反映在每个分辨单元的回波信号幅度和相位上。因此扩展目标的回波模拟实现，首先对雷达发射信号进行脉内调制，然后将散射特性数据与该发射信号进行卷积运算，最后即可得到扩展目标雷达的回波信号。  </p>
</blockquote>
<p><strong>疑问：对该推导保留意见，其中$\tau_{i1}$表达式中的n怎么选取？</strong></p>
<p><strong>疑问：卷积序列的长度选取？或者频域处理长度选取？</strong></p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>简单来看冲激响应函数为delta函数的时移和叠加(简化忽略幅度信息)，那么问题就是如何量化该h(t)，使得输入信号与该h(n)相卷积？  </p>
<p>这与雷达波形的延时范围有关，也就是冲激函数的长度。  </p>
<p>Reference: <a href="http://cdmd.cnki.com.cn/Article/CDMD-10007-1015029826.htm" target="_blank" rel="external">雷达扩展目标回波模拟技术研究与实现</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[卷积的物理意义]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89/</url>
      <content type="html"><![CDATA[<p>今天仿matlab的时候用到卷积函数<code>conv(u, v)</code>，然后看到参考文档中的描述是  </p>
<blockquote>
<p>Convolution and polynomial multiplication</p>
</blockquote>
<p>突然就觉得很奇怪，为什么会等价于多项式乘法呢。<br>然后看了下example吓了一跳，从数学表达式上来看完全就是一样的东西嘛。  </p>
<blockquote>
<p>Create vectors u and v containing the coefficients of the polynomials $x^2+1$ and $2x+7$.<br><code>u = [1 0 1];</code><br><code>v = [2 7];</code><br>Use convolution to multiply the polynomials.<br><code>w = conv(u,v)</code><br>w =   2     7     2     7<br>w contains the polynomial coefficients for $2x^3+7x^2+2x+7$.</p>
</blockquote>
<p>然后就去google卷积，发现了知乎上一个回答挺有趣的，<a href="https://www.zhihu.com/question/22298352/answer/34267457" target="_blank" rel="external">怎样通俗易懂地解释卷积？</a><br>这个回答中的图示没有用教科书中讲的反褶+时移相乘，而是$x[n]$乘以$y[k]$的时移和叠加。回答者的描述是  </p>
<blockquote>
<p>可以看到卷积的重要的物理意义是：一个函数（如：单位响应）在另一个函数（如：输入信号）上的加权叠加。<br>通俗的说：<br>在输入信号的每个位置，叠加一个单位响应，就得到了输出信号。</p>
</blockquote>
<p>回想一下信号与系统的知识，可以说这个回答非常符合认知，也能和上面的多项式相乘对应起来。<br>接触了很久的卷积现在才发现有着这么层意思在里面，只能说当年学得太渣…残念…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数字信号的基带传输和载波传输中的几个点]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%9F%BA%E5%B8%A6%E4%BC%A0%E8%BE%93%E5%92%8C%E8%BD%BD%E6%B3%A2%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="成型滤波"><a href="#成型滤波" class="headerlink" title="成型滤波"></a>成型滤波</h3><p>升余弦滚降信号：以 $\pi /t$ 为中心，具有奇对称升余弦个月形状过渡带的一类的无串扰波形。其中滚降系数 $\alpha$ 介于0~1之间，$\alpha$=0 时为具有最窄频带的无串扰波形（奈奎斯特带宽），频带利用率最高但实际不可能达到。  </p>
<p>升余弦滚降信号占用带宽 $B=(1+\alpha )f_s/2$，$\alpha$ 越大，传输频带越大，而波形振荡起伏越小，抽样时刻误差越小。通常取 $\alpha \geq 0.2$。    </p>
<a id="more"></a>
<h3 id="匹配滤波器"><a href="#匹配滤波器" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h3><p>$H(f)=KS^*(f)e^{(-j2\pi fT)}$<br>输出信噪比最大的滤波器，其传递函数与信号频谱的复共轭成正比，称为匹配滤波器。  </p>
<p>$h(t)=KS^*(T-t)$<br>匹配滤波器的冲击响应是输入信号$S(t)$的镜像及平移。  </p>
<p>匹配滤波器的输出信号波形与输入信号的自相关函数成比例。  </p>
<h3 id="MPSK"><a href="#MPSK" class="headerlink" title="MPSK"></a>MPSK</h3><p>多进制相移键控，载波相位有M种取值。  </p>
<p>已调信号时域表达式可简写为，$S_{MPSK}(t) = I(t)\cos(\omega_c t) - Q(t)\sin(\omega_c t)$，所以可用正交调制的方法产生。这里<br>同相分量 $I(t) = \Sigma a_n rect(t-nT_s)$<br>正交分量 $Q(t) = \Sigma b_n rect(t-nT_s)$<br>其中rect矩形函数，即为矩形包络，可使用成型滤波的升余弦滚降信号作为包络吧？<br>而$a_n=Acos\phi(n)$, $b_n=Asin\phi(n)$。  </p>
<p>8PSK相干调制时，每3bit产生一3位码组$b_1 b_2 b_3$，在其控制下同相路和正交路分别产生两个四电平基带信号I(t)和Q(t)，$b_1$决定同相路信号极性而$b_2$决定正交路信号极性，$b_3$则确定两路信号的幅度，分别为$cos\pi /3$和$sin\pi /3$，即两路基带信号幅度互相关联，不可独立选取(使合成矢量端点落在圆上)。<br>还有相位选择法调制(适用于高载频)和脉冲插入法调制。其中选相法，我觉得在DDS中通过符号对应相位偏移就可以简单实现。  </p>
<p>可用两正交载波信号实现相干解调，区别在于多进制调制时为多电平判决，如QPSK为二电平判决而8PSK为四电平判决。</p>
<h3 id="MQAM"><a href="#MQAM" class="headerlink" title="MQAM"></a>MQAM</h3><p>正交幅度调制(Quadruate Amplitude Modelation)，为幅度与相位相结合的调制方式，在星座图上区别于MPSK的圆上均匀分布，MQAM在圆内按矩形或十字形等距离分布，矢量端点距离更大，抗干扰能力更强。  </p>
<p>在两正交载波上进行幅度调制实现，区别于MPSK，MQAM的同相和正交两路基带信号的电平相互独立。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[雷达波形与信号]]></title>
      <url>http://bonewp.github.io.git/2017/03/28/%E9%9B%B7%E8%BE%BE%E6%B3%A2%E5%BD%A2%E4%B8%8E%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h3 id="雷达的分辨率"><a href="#雷达的分辨率" class="headerlink" title="雷达的分辨率"></a>雷达的分辨率</h3><p>雷达波形$u(t)$的自相关函数主瓣宽度越窄，其距离分辨能力越强。即若要时间（距离）分辨率好，应选择这样的信号，即它通过匹配滤波器后应该输出很窄的主瓣波峰。这样的信号或是具有很短持续时间的脉冲，或是具有很宽频谱的宽带波形。  </p>
<p>瑞利时间分辨率：$\delta_t = 1/B$，或等效地，瑞利距离分辨率：$\delta_r = c/{2B}$。  </p>
<p>多普勒频率分辨率:$\delta_{fd} = 1/T$，或对目标径向速度分辨率:$\delta_v = \lambda / {2T}$。  </p>
<p>总结：</p>
<ol>
<li><strong>雷达的距离/时间分辨率由雷达发射信号的带宽决定。</strong> 该带宽可以是瞬时的(如极窄的脉冲)，也可以是合成的(通过时间换取，如脉冲持续时间长的线性调频波)。在实际应用中，该宽带信号可是窄脉冲波形、线性调频波形、频率步进波形、随机或伪随机噪声波形及其他任何宽带调制信号。  </li>
<li><strong>雷达的速度/多普勒分辨率由信号的持续时间决定。</strong> 持续时间越长，分辨率越高。可通过发射持续时间长的脉冲或通过多个脉冲的相参积累等实现。  </li>
</ol>
<a id="more"></a>
<h3 id="线性调频脉冲LFM"><a href="#线性调频脉冲LFM" class="headerlink" title="线性调频脉冲LFM"></a>线性调频脉冲LFM</h3><p>Linear Frequency Modulation，LFM。对雷达波形进行调频得到宽带信号，分为上变频和下变频。  </p>
<p>该体制采用宽脉冲发射以提高发射的平均功率，保证足够大的作用距离；而接收时采用相应的脉冲压缩算法获得窄脉冲，以提高距离分辨率，较好的解决雷达作用距离与距离分辨率之间的矛盾。</p>
<img src="/2017/03/28/雷达波形与信号/LFM信号示意图.jpg" alt="LFM信号示意图.jpg" title="">  
<p>设线性调频信号为$s(t) = 1/\sqrt{t_p} rect(t/t_p)e^{j(\omega_c t+\pi \gamma t^2)}$<br>其中$\omega_c$为发射中心频率，$t_p$为脉冲宽度，$\gamma$为线性调频斜率，$B=\gamma t_p$。<br>包络调制函数为$u(t) = 1/\sqrt{t_p} rect(t/t_p)e^{(j\pi \gamma t^2)}$<br>随时间变化的频率函数为$f(t)=1/{2\pi}d/{dt} (\omega_c t + \pi \gamma t^2) = \omega_c/{2\pi}+\gamma t$  </p>
<p>Matlab仿真代码示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">%%demo of chirp signal</div><div class="line">T=20e-6;                          %pulse duration us</div><div class="line">B=50e6;                           %chirp frequency modulation bandwidth MHz</div><div class="line">K=B/T;                            %chirp slope</div><div class="line">Fs=4*B;Ts=1/Fs;                   %sampling frequency and sample spacing</div><div class="line">N=T/Ts;</div><div class="line">fc=0;</div><div class="line">t=linspace(-T/2,T/2,N);</div><div class="line">St=exp(1i*pi*K*t.^2);                 %generate chirp signal</div><div class="line">St=St.*exp(1i*2*pi*fc*t);</div><div class="line">subplot(211)</div><div class="line">plot(t*1e6,real(St));</div><div class="line">xlabel(&apos;Time in u sec&apos;);</div><div class="line">title(&apos;Real part of chirp signal&apos;);</div><div class="line">grid on;</div><div class="line">subplot(212)</div><div class="line">freq=linspace(-Fs/2,Fs/2,N);</div><div class="line">plot(freq*1e-6,fftshift(abs(fft(St))));</div><div class="line">xlabel(&apos;Frequency in MHz&apos;);</div><div class="line">title(&apos;Magnitude spectrum of chirp signal&apos;);</div><div class="line">grid on;</div></pre></td></tr></table></figure></p>
<p>结果如下<br><img src="/2017/03/28/雷达波形与信号/lfm信号仿真结果.png" alt="lfm信号仿真结果.png" title="">  </p>
<h3 id="脉冲压缩"><a href="#脉冲压缩" class="headerlink" title="脉冲压缩"></a>脉冲压缩</h3><p>线性调频斜率为$\gamma$、脉宽为$t_p$的脉冲，通过匹配滤波器后，时间分辨率为$1/\gamma t_p$。对于雷达接收机而言，相当于输入脉冲的宽度为$t_p$，输出脉冲宽的为$1/\gamma t_p = 1/B$，即输出与输入脉冲宽度之比为$1/\gamma t_p^2$。<br>在LFM雷达中，$\gamma t_p^2$通常称为时宽带宽积，且有$\gamma t_p^2 \gg 1$。<br>可见，接收机（匹配滤波器）的输出脉冲宽度在时间上被“压缩”，称之为脉冲压缩(Pulse compression)。<br>也就是说，为了获得线性调频信号的大带宽所对应的高级了分辨能力，必须对接收到的LFM宽脉冲回波进行压缩滤波处理（匹配滤波），使其变为窄脉冲。   </p>
<p>实现上，数字方法有非递归滤波器（时域卷积），正-反DFT（频域分析），后者占用内存少、运算量小、速度快，更长用。  </p>
<p>为了抑制旁瓣，减少虚警，常用加权处理。即将匹配滤波器的频率响应乘上某些适当的“窗函数”，在时域中相当于一系列加权函数组成的滤波器和匹配滤波器级联。  </p>
<p>Reference: 《雷达系统及信息处理》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cadence使用及画板技巧相关]]></title>
      <url>http://bonewp.github.io.git/2017/03/02/Cadence%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%94%BB%E6%9D%BF%E6%8A%80%E5%B7%A7%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>在课题组这儿画了好几块PCB了，感觉使用Candence画板这活完全就是经验性的工作。学习曲线陡峭，简直就是个阶跃函数，掌握了基础之后就是不断在实际操作中熟练技巧(为什么你这么熟练啊…)。画原理图的时候如果没有以前的参考还会相对复杂一点，要对照datasheet按照要求来连接逻辑关系，布PCB简直就是堆工作量了，经常陷入长时间布线停不下来，总想多做一些早点搞完，但是实际上已经累得头晕脑胀的毫无效率了(珍爱生命远离画板…)。<br>虽然这么说但是过程中需要注意的地方也挺多的，这里把自己以前学习的小记和操作过程的思考记录下来，以后操作前先复习一下以免多次无意义的工作(没错 就是经常删了重布 删了重布)。  </p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Cadence提供了两个集成的、从前端到后端的设计结局方案：Concept-HDL到Allegro；Capture到Allegro。<br>Capture CIS区别于Capture的地方在于CIS——Component Information System，该模块可对元器件和库实施高效管理，还可通过Internet Component Assistant查阅添加元器件。（不过我基本上没用过，都是自己保存的元件库，这个还需注意吧）<br>设计总体思路：</p>
<ol>
<li>原理图：根据框图，确定元器件，若库里无相应器件，需自己画器件模型；再连接元器件之间的端口。首先确定各个模块（每一个文件夹就对应一个模块Schematic Design—Schematic Folder—Schematic Page），在模块内各page连线，再在TOP层将各个模块连接起来。</li>
<li>PCB：根据原理图确定下来的连接关系，对元器件进行具体的布局布线。首先确定板卡的尺寸、固定孔，然后布局（根据具体需求和指导原则），接着布线，最后检查其合理性，对不足的地方修改<del>或者推翻重来</del>。   </li>
</ol>
<img src="/2017/03/02/Cadence使用及画板技巧相关/制板总体设计思路.png" alt="制板总体设计思路.png" title="">  
<h3 id="原理图设计"><a href="#原理图设计" class="headerlink" title="原理图设计"></a>原理图设计</h3><h4 id="元件库制作"><a href="#元件库制作" class="headerlink" title="元件库制作　"></a>元件库制作　</h4><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>如果在参考项目中有需要修改的package，点击该元器件—Edit Part—View Package—save as选择自己的元件库保存。  </li>
<li>如果已有的库里没有元件对应的package，可上官网找CAD文件用官方软件转换为.olb，复制到自己的库中。如果没有，按照管脚定义列表excel自己画。Excel也找不到就自己画吧。</li>
<li>元件会有多种封装，不同封装管脚排列不同，如AD9236有RU-28和CP-32-2两种，分别对应尾缀：BRU和BCP。一般在芯片手册的Order Information或Ordering guide中会包含完整的尾缀和封装对应关系。</li>
<li>元件库名称必须带有表示元件封装的尾缀信息</li>
<li>为实现后续功能，元件库管脚类型(type)必须与实际元件一致<br>常用的管脚类型有：Input, Output,3state,Bidirectional,Open Collector,Open Emitter,Passive,Power等</li>
<li>同一功能有多个管脚，在管脚功能后用不同数字区分(如VCC1,VCC2,GND1,GND2)；数字命名在管脚数较小时按照递增编号；管脚数较多时，可用管脚号（如VCCINT56表示该电源管脚在第56号管脚上）</li>
<li>一般应将管脚按照功能分组摆放</li>
<li>元件管脚必须置于编辑界面的网格(grid)上，否则画原理图时会出现连接错误。</li>
</ul>
<h5 id="制作元件"><a href="#制作元件" class="headerlink" title="制作元件"></a>制作元件</h5><ol>
<li>新建元器件：New library-new part。  </li>
<li>放置引脚：<br>单个引脚Place Pin：其中Number管脚号是非常重要的属性，在PCB设计中，使用Number属性与封装的PinNumber对应，从而建立原理图与PCB的联系。管脚号不光可以是数字，也可以是字母，或字母数字的组合（如某些BGA封装）的管脚号就是字母数字组合。但必须和封装上的管脚号一一对应。<br>多个引脚Place Pin Array—&gt;edit Properties。调整顺序，沿虚线框画矩形外框。<br>在制作FPGA等引脚非常多的元件时，官网会有相关文件方便制作。  </li>
<li>绘制外形：Place-Line or Rectangle。<br>绘制完成后保存至相应的.olb中。<br>另一种方法：new part from spreadsheet，按照datasheet填写表格，其中No. of Section用于表示元件中的第几个part（在multipule-part package情况下）。</li>
</ol>
<h5 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h5><p>Package包装：即库中一个完整的元件，一个Package一般对应PCB中一个元件的封装(Footprint)。<br>Part部件：组成一个完整元件的一个或多个部分。某些元件内部可以按照功能划分为多个部分，每一部分占用元件的一部分管脚。<br>Single Part：元件由唯一的Part组成，大多数简单器件。<br>Multipule Part Package：</p>
<ul>
<li>Homogeneous：内部各Part功能和符号完全相同的元件。每个Part的图形和管脚数和功能都是相同的，但管脚号可以不同。并且可以有部分重复的管脚(如74LS14每个Part上均有VCC和GND两个管脚，不过这些重复的管脚应该都是对应的实际上同一个管脚）。不能使用[New Part From Spreadsheet]制作。</li>
<li>Heterogeneous：元件由多个不同的Part组成。不允许同一个管脚在不同Part中出现（软件不会报错）。  </li>
</ul>
<h4 id="原理图层次"><a href="#原理图层次" class="headerlink" title="原理图层次"></a>原理图层次</h4><p>一个原理图design包含多个模块Block（有一个root schematic即顶层模块），而模块由多个Page组成。<br>Block上的端口(Port)来自于图中各Page上放置的Port符号。如果把Block也看成一个芯片，则Port是这些芯片的管脚。<br>Off Page Connector的作用是连接同一个图中不同页(page)的电路。而Net alias用于连接同一个Page内的电路。<br>电源端口是全局的。  </p>
<h4 id="原理图制作"><a href="#原理图制作" class="headerlink" title="原理图制作"></a>原理图制作</h4><h5 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h5><p>New-Project。在circuit文件夹下创建sch和pcb分别存放原理图和pcb设计。  </p>
<h5 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h5><p>包括Title Block和Page Size： [Option]-[Design Template]- Title Block-Symbol。<br>New symbol可创建特殊元件，如TitleBlock、电源、地、port、off-page connecter；改变图纸大小Schematic Page Properties-Page Size一般选B及以下。  </p>
<h5 id="创建顶层页面"><a href="#创建顶层页面" class="headerlink" title="创建顶层页面"></a>创建顶层页面</h5><p>Root Design中分别建立Page1: Title、Page2: Topology和Page3: Top三个页，在Topology页中绘制或粘贴电路框图。  </p>
<h5 id="添加库"><a href="#添加库" class="headerlink" title="添加库"></a>添加库</h5><p>[Place]–[Part]中添加自己的元件库以。注意“Design Cache”并不是一个真正的库文件，而是当前工程的设计缓冲。  </p>
<h5 id="分模块画子图"><a href="#分模块画子图" class="headerlink" title="分模块画子图"></a>分模块画子图</h5><p>[New Schmatic]-[New Page]创建子图。然后放置元件，重点检查元件标号(Part Reference)和封装(PCB Footprint)，修改value。快捷键H，V，R可分别左右、上下调换元件和旋转元件。<br>放置电源、GND符号，端口符号等，然后wire连接逻辑关系。</p>
<h5 id="指定net-alias"><a href="#指定net-alias" class="headerlink" title="指定net alias"></a>指定net alias</h5><p>一般与端口相连的网络名称应与端口名称相同。网络标号只在Page内起作用，因此不同Page中的网络标号是可以相同的。</p>
<h5 id="在顶层图中放置子模块"><a href="#在顶层图中放置子模块" class="headerlink" title="在顶层图中放置子模块"></a>在顶层图中放置子模块</h5><p>[Place]-[Hierarchical Block]。缺省情况下，所有的输入都在左边，所有的输出都在右边，可以根据绘图需要进行调整。<br>若修改了Page中的设计，如使用Place H pin增加、减少了Port，可以在Block处使用[Synchronize Up]命令，更新Block。如果在Block上增加了Port或减少了Port，则可以使用[Synchronize Down]。  </p>
<h5 id="原理图复用"><a href="#原理图复用" class="headerlink" title="原理图复用"></a>原理图复用</h5><p>一个Schematic作为一个Block在顶层中可以复用。<br>原始的属性所代表的元件，称为Instance，对应属性页中的白色一列；而由于复用新增的两列所代表的多个同类元件，称为Occurrences，对应属性页中的黄色列。在存在复用的设计中，Occurrences中的属性(可不同)，才是真正使用的属性(在导出PCB网表时使用)。  </p>
<h5 id="电路模块级的重用"><a href="#电路模块级的重用" class="headerlink" title="电路模块级的重用"></a>电路模块级的重用</h5><p>可将一整个已有的电路设计复用，原理图对应相应的.dsn，PCB布局对应相应的.mdd（需要在PCB中添加至Module Path中）。其中可重用DSN原理图中的元件经过特殊处理，具有Reused ID属性。若被外部引用的DSN名为DsnName；而DSN中被引用的schematic名称为SchName，则对应的MDD文件名称应为DsnName_SchName.MDD。在PCB设计时，.dsn和.mdd通过文件名来匹配。<br>[Place]-[Hierarchical Block]-[Browse…]找到复制过来的xx.dsn（设置文件名才能与PCB中的.mdd匹配）。<br>在[Browse]选择文件后，Path and filename中为DSN文件的完整路径，为保证整个Sch目录复制到别的机器或目录还能改正确打开原理图，必须将其改为相对路径。  </p>
<h5 id="分配元件标号"><a href="#分配元件标号" class="headerlink" title="分配元件标号"></a>分配元件标号</h5><p>选中.dsn—annotate。注意Action中Unconditional reference update一般不使用，另Reset reference numbers to begin at 1 in each page也绝对不能选中，会导致标号重复。<br>第一步：将页面中的标号都置为“？”。Scope选Update entire design，Action选Reset intersheet References，Mode选Preferred，选中Include non-primitive parts（即将Block也标号），确定即可。<br>第二步：若没有使用外部重用模块（.dsn .mdd），则Action选中Incremental reference update确定即可。若使用了外部重用模块，则在Allegro Reuse中标号。  </p>
<h5 id="DRC电气规则检查"><a href="#DRC电气规则检查" class="headerlink" title="DRC电气规则检查"></a>DRC电气规则检查</h5><p>DRC检查管脚连接冲突、总线宽度匹配，短路（同一个元件管脚上有多个网络名）等原理图设计中潜在的错误。检查范围有限，可能误报，需谨慎仔细查看。<br>Edit—browse—DRC Markers可查看检查出的错误。  </p>
<h5 id="网表导出netlisting"><a href="#网表导出netlisting" class="headerlink" title="网表导出netlisting"></a>网表导出netlisting</h5><p>在导出网表之前必须将所有元件的PCB Footprint属性填好（如果某些元件的封装还没有画，也要先填一个名字）。<br>Tools—create netlist，在PCB editor页面选中Create or Update Allegro PCB Editor Board，若是修改了原理图更新PCB，则要选择input board。Place changed需要注意下。  </p>
<p><strong>一定要注意在打开的PCB中另存至pcb文件夹中！！！这是血泪的教训啊！！！不然再次导出是要被覆盖的啊！！！</strong>  </p>
<p><strong>注意</strong>：导出时若遇到ERROR(ORCAP-36004)，是对多part元件编辑时，软件会自动给编辑的part添加尾缀造成多part不一致，在Edit part页面选择Options-Package properties删掉尾缀。若是有多次编辑，则会提示错误封装名重复。这时进Design Cache将相应的封装用自己的库替换掉。注意以后要避免直接修改Part封装导致这种错误，而要在库中修改再替换。  </p>
<p><strong>注意</strong>：可以使用edit—browse—选择相应的器件进行修改。比如修改part的footprint，就可以进入part，选择需要修改的元件，ctrl+E修改属性里的footprint。修改port、net的名称也可以这样做。<br>也可以Ctrl+F查找器件，如查找所有电阻，则在查找选项里选中parts，然后搜索R*，即可选中所有的电阻进而修改footprint。<br>也可以直接选中一页或.dsn，右键选择edit object properties。</p>
<h3 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h3><p>备注：1 mil=1 inch/1000=25.4mm/1000<br>1 mm=39.37…mil≈40mil  </p>
<h4 id="制作焊盘"><a href="#制作焊盘" class="headerlink" title="制作焊盘"></a>制作焊盘</h4><p>Pad Designer-Parameter中，type焊盘类型有：Through通孔、Blind盲孔、single单层，其他参数自己看看吧。<br>Layer中，需要定义每层的参数。一般需要定义的信号层有Begin Layer、Default Internal、End layer（对于过孔来说就这三个层就足够了，中间层都会用Default internal的参数自动匹配），另外非信号层一般还需要定义：Soldermask_top、Soldermask_bottom(阻焊）。在设计PCB时，阻焊层（Soldermask_top和Soldermask_bottom）是反向显示的，即不涂阻焊材料的地方是一个填充的图形，覆盖阻焊的地方没有图形。PCB上一般只有焊盘上不会覆盖阻焊材料，其它的连线、铺铜都被阻焊材料覆盖。一般直径要多设10mil。  </p>
<p>Regular Pad是通常意义下的焊盘，大小根据datasheet设定，一般焊盘宽度应该大于至少等于管脚宽度，焊盘长度两倍于管脚长度使之对准中心（焊盘间距5mil以上没问题）；Thermal Relief是焊盘要与周围敷铜连接时的状态，若焊盘和周围铺铜的网络相同，会自动用4或8条将焊盘与周围铺铜连接，周围铺铜与焊盘边缘隔开的距离是Regular的半径和Thermal Relief半径之差，建议直径多设12mil；Anti Pad是焊盘与周围的铺铜网络不同（因该绝缘开）时隔离的形式。  </p>
<p>总结下来涉及到的数据有：<br>Drill diameter    按需<br>Regular Pad    按datasheet，焊盘宽度大于等于管脚宽度最大值，焊盘长度两倍于管脚长度中间值<br>Thermarl Relief    大12~16mil (0.3~0.4mm)<br>Anti pad    大12~16mil (0.3~0.4mm)<br>Soldermask    直径大regular pad 8~10mil，长宽都大8~10mil (0.2~0.25mm)  </p>
<h4 id="制作封装package-symbol"><a href="#制作封装package-symbol" class="headerlink" title="制作封装package symbol"></a>制作封装package symbol</h4><p>用封装来表示元件管脚、物理尺寸以及管脚位置等信息。不同的元件如电阻、电容可能会用相同的封装，如0402、0603。<br>PCB封装只代表器件的尺寸大小等物理特性，封装上的管脚本身没有任何电气属性；而原理图符号是一个器件电气上的抽象表示，代表着器件管脚的输入、输出等电气属性，但符号本身不包含尺寸、管脚位置等物理特性。</p>
<p>原理图中符号通过PCB Footprint属性与PCB封装库中的同名封装对应；原理图符号上的管脚与封装的对应焊盘对应（管脚号与焊盘号对应）.<br>一个package symbol与两个文件对应：.dra文件可编辑；.psm不可编辑，由.dra生成，需添加至psmpath。  </p>
<p>Allegro中有很多对象都叫symbol，如Mechanical Symbol（机械符号）、Format symbol（图纸格式符号），Shape symbol（形状符号，画异型焊盘时能用到），以及Flash symbol（在焊盘设计中用来确定特殊形状的Thermal和anti Pad）。这些符号设计阶段都是*.dra文件，然后生成对应的symbol文件，但扩展名是xxm(xx是其它字母）。在PCB设计时，如果要使用这些symbol，都须要把xxm所在目录加入design_path中。  </p>
<p>注意几个概念：<br>Ref Des–reference designation元件标号在Silk Screen层，如U<em>,R</em>,C*等；<br>封装占用面积，用Place_Bound_Top画一个封闭区域(Shape)来表示；<br>Package Geometry封装轮廓在Silk Screen层，生产时与Ref Des的Silk Screen合并成一个光绘文件，用于在PCB表面印字。  </p>
<p>具体步骤  </p>
<ol>
<li>模板向导<br>[File]-[New]- Package symbol(wizard)——选择类型、模板——<br>确定管脚数(N)，管脚间距(e)必须精确，焊盘中心距离（e1）取偏大（就最大宽度），封装外形丝印的宽度（E）取最小、高度(D)取最大——选择焊盘padstack——选择参考坐标symbol origin，并选中Do not create a compiled symbol在后续创建。  </li>
<li>修改封装<br>调整grid以便编辑——添加1管脚标注：选择圆形Shape–Option页选择Active Class and Subclass为“Package Geometry和silk_screen_Top—选择圆心在管脚1右边—命令行ix 0.5（单位mm）确定半径。</li>
<li>生成符号文件.psm<br>[File]-[Create Symbol]生成PCB设计使用的Symbol文件。一般将所有封装的Symbol文件都放在一个目录下以备使用。  </li>
</ol>
<p><strong>注意</strong><br>封装符合要求的条件：合适的焊盘大小；精确的焊盘间距；Component—Ref Des—Silkscreen 层元件标号前缀；Package Geometry— Silkscreen层元件外形轮廓； Package Geometry—Silkscreen层绘制极性方向、1管脚方位；[Setup]-[Aereas]-[Package Boundary]定义元件实际PCB面积。（用向导绘制基本上已经概括完了）<br>Package Geometry的Silkscree_Top以及Component—Ref Des元件标号中的Silkscreen_Top在后续处理中会作为PCB顶层丝印的一部分；<br>Commond命令：<br>x 10 20 : 将鼠标定位在绝对坐标 (10,20)处<br>x 20 : 不改变上一次鼠标点击的y坐标，将x坐标定位在x坐标为20处<br>y 30: 不改变上次点击的x坐标，将y坐标定位在30<br>ix 10 20：相对于上次点击的位置，x向右移动10，y向上移动20<br>ix -10：相对于上次点击的位置，x向左移动10<br>iy 10：相对于上次点击的位置，y向上移动10  </p>
<h4 id="制作机械符号（画外框）"><a href="#制作机械符号（画外框）" class="headerlink" title="制作机械符号（画外框）"></a>制作机械符号（画外框）</h4><p>PCB机械符号包括：</p>
<ul>
<li>PCB的外形、尺寸要求；</li>
<li>PCB的安装固定要求；</li>
<li>系统中其它部件在PCB上安装固定的要求，抗冲击的PCB上的金属加强结构</li>
<li>PCB上禁止布线、和放置元件的区域（或允许布线、放置元件的区域）</li>
<li>PCB上接插件放置的位置</li>
<li>PCB在制造过程中切割、倒角等要求等  </li>
</ul>
<p>需要制作Mechanical Symbol的场景：完全自由设计，比如设计一个实验板，可以自由定义板子的外形、尺寸等。这种情况不用设计专门的Mechanical Symbol，只需在PCB设计环境用Board Geometry用line画一个框即可定义电路板的外形。<br>不需要制作Mechanical Symbol的场景：多种PCB使用同样的机械定义，如同一种形式的板子会设计很多种；由业界标准定义的PCB，如PCI板卡、VME、CPCI板卡等；设计好后可以反复利用。<br>下述的处理不管在需要制作Mechanical Symbol的场景，或是直接在工程中画外框的场景都会用到：  </p>
<ul>
<li>设置图纸大小：[Setup]-[Design Parameter]-[Design]，设置单位和Extents，确定原点和宽高。</li>
<li>画PCB外框：选择[Add]-[Line]菜单，再选择右侧属性页中的子类为Board Geometry–Outline；根据尺寸输入命令确定外框。注意画外框时要一条边一条边地画，否则后面倒角不能选择segment。</li>
<li>倒角：[Manufacture]-[Drafting]-[Chamfer]命令，在右侧的Option窗口输入Trim Segments和Chamfer angle为：First2；Second0；Chamfer angle45；若是倒圆角则选择Fillet。</li>
<li>安装孔：Add Circle、Add Line。画好一个孔后，使用复制功能，并iy/ix至相应位置。</li>
<li>添加尺寸标注：[Manufacture]-[Dimension Environment]，右键选择Parameter设置单位，右键选择需要的标注项进行尺寸标注。  </li>
</ul>
<h4 id="画图前的设置"><a href="#画图前的设置" class="headerlink" title="画图前的设置"></a>画图前的设置</h4><h5 id="层叠结构Cross-Section"><a href="#层叠结构Cross-Section" class="headerlink" title="层叠结构Cross Section"></a>层叠结构Cross Section</h5><p>[Setup]-[Cross-section]：添加层的属性，Layer Type中Conductor为通常用于走信号线的层、Plane为平面用于电源或地（平面即整一层铺铜均属同一个网络，有时一个平面可分割成多个区域用于不同的电源或地，注意需保证其较大面积和低阻抗连接路径）。  </p>
<p>常用的层叠结构有：双面板TOP BOTTOM；四层板TOP GND1 PWR1 BOTTOM；六层板TOP GND1 SIG1 SIG2 PWR1 BOTTOM；八层板TOP GND1 SIG1 PWR1 GND2 SIG2 PWR2 BOTTOM。</p>
<h5 id="设置工作路径Design-Path"><a href="#设置工作路径Design-Path" class="headerlink" title="设置工作路径Design Path"></a>设置工作路径Design Path</h5><p>[Setup]-[User Preferences]-[Design Path]：module path为复用MDD文件路径；PAD Path为焊盘路径；Psm Path要设置用到的所有symbol的路径，包括packages symbol(psm–pcbsymb)，mechanical symbol(bsm–pcbMechSymb)，以及pcbFlashSymb，PadShapes；</p>
<p>添加过孔：Constraints-Physical-All layers选择Vias添加需要用的过孔。</p>
<h5 id="设置图纸大小、单位、边框、颜色"><a href="#设置图纸大小、单位、边框、颜色" class="headerlink" title="设置图纸大小、单位、边框、颜色"></a>设置图纸大小、单位、边框、颜色</h5><p>参考上小节制作机械符号。<br>颜色可使用已有的script。另一种方法：在已有板子的基础上且层叠结构的名字一致，可export-parameter选中color相关参数，再在需导入brd中import-parameter。</p>
<h5 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h5><p>Command中键入echo $localenv找到env文件的路径。打开env（没有就自己创建）,在一堆#前输入快捷键命令。如alias ~E move(注意这里要大写)，funckey w add connect。注意alias命名的可在Command输入但不能设置单键，而funckey则可以设置单键。<br>可在Tools-Utilities中查看支持的键盘命令以及已有的快捷键。</p>
<h4 id="敷铜"><a href="#敷铜" class="headerlink" title="敷铜"></a>敷铜</h4><p>Shape–Polygon敷铜(可Edit—Z-copy复制平面到另一层)。<br>方法一：敷铜前可以先选择相应的电源/地net高亮，然后再在Shape中选择net画形状，注意拐角取45度。<br>方法二：先画好一整块敷铜，再Anti Etch分割平面。  </p>
<p>Shape—Edit Boundary可任意更改敷铜的边界。注意敷铜与过孔的连接可在Shape—Global Dynamic Params中修改，热风焊盘Thermal relief connects中连接方式一般Full connect或Orthogonal正交。<br>需要在敷铜中间挖空时，选择Shape—Manual Void。<br>不同电源信号的敷铜间隔最小可至0.2~0.3mm。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>PCB中灰绿色的连线叫做(Rats)，表示需要连接而还未连接的网络；<br>[Place]-[Quick Place]：可将剩余的所有元件都暂时放到PCB中，再慢慢摆位置；<br>可通过与原理图互动来选择元器件。这样可以根据信号的流向来逐个放置元件，有利于边放置边检查电路原理图，同时也利于根据元件的功能来考虑放置位置。  </p>
<h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><p>可在[Display]-[Show Rats]-[Components]选择显示相应器件的飞线。<br>走线宽度一般不小于6mil(0.1524mm)，线间距以3W原则即：走线中心之间距离至少为线宽的三倍，这样可使走线在另一走线的70%磁通量边界范围外，若要到98%，线间距需大10倍线宽。<br>差分线的线宽和线距理论上是用工具计算的（SI9000），但是没用过…目前用过的线距/线宽有8/4.5、6/4 mil。<br>注意绕线的时候，一般选择3x space。</p>
<h5 id="差分线"><a href="#差分线" class="headerlink" title="差分线"></a>差分线</h5><p>在Setup-Constrains-Constrains Manager中的Electrical-ECS设置布线规则，重点在等长（Static Phase），视具体情况可设为5mil(0.127mm)；然后在Net中为差分对绑定相应的规则。</p>
<p>总线做等长约束在Relative Propagation Delay中Create Match Group再定义约束参数。注意参数中的Delta:Tolerance，Delta指需要设置的值与Target的差值，设为0即可；Tolerance指可容忍的延迟差值，按需要设为0.2~0.3mm或者更大。<br>在Physical中设定宽度（Line Width）等参数；<br>在Spacing中为差分对设定对与对之间的间隔（Line to All）,似乎在Ecs和Pcs中设定的Gap优先级更高，这里设定Line to line应该只对差分对之间起作用。注意！在ECS中要设置Min Line Spacing的值，否则会提示间距错误的DRC。<br>设定差分对时进入Auto Setup设置后缀后可自动设置。<br>注意在Setup-Constrains-Mode中将需要检查的DRC打开，否则不会显示。</p>
<h5 id="扇出"><a href="#扇出" class="headerlink" title="扇出"></a>扇出</h5><p>Fanout，在焊盘引脚附近打孔再连接线。可在Route-PCB router-fanout by pick选择symbol自动扇出，右键Setup可进行相关设置。若对连线有要求可先在Constrains manager中修改默认走线宽度。</p>
<h5 id="Xnet"><a href="#Xnet" class="headerlink" title="Xnet"></a>Xnet</h5><p>约束走线等长时，会遇到一个电阻/电容连接的两根线看做同一条net来约束长度的情况，此时需要将这个电阻两端的net组合为Xnet。<br>方法：Analyze—Model Assigment—选择需要设置的电阻/电容—进入设置页面选择对应管脚—Ok。然后再在约束管理器中选择Xnet约束等长。</p>
<h4 id="制板"><a href="#制板" class="headerlink" title="制板"></a>制板</h4><p>光绘文件和钻孔文件；<br>说明所制作PCB的厚度，各层的重叠顺序（如对PCB上走线的阻抗等有特殊要求，一般应指出层叠结构、介质类型）；<br>明确最小线宽、最小线距、最小钻孔等加工工艺；</p>
<h4 id="复用模块"><a href="#复用模块" class="headerlink" title="复用模块"></a>复用模块</h4><ol>
<li>在原理图中，选择根项目 Annotate-PCB Editor Reuse，选择Generate Reuse module并确定后，选择原理图中所有器件右键Edit Properties，能看到每个器件有唯一的Reuse ID属性，说明复用模块生成成功。</li>
<li>从原理图生成PCB布局布线完成后，选择Tools-Create Module，框住所有器件并选择原点，另存为mdd复用模块，注意名字必须是原理图项目名_根page名的级联。</li>
<li>在需要用复用模块的原理图中，新建Hierarchical Block，Implementation Type选择Schematic View，Path选择复用模块.dsn，Implementation name选择复用模块Page名称。摆放完成后，在Tools-Annotate中选择PCB Editor Reuse，Function中选择Renumber design for reuse module，并在对下方选择好复用模块，这样就完成了复用模块在工程中的标号。生成PCB后在Place-Manually中选择Module Instance摆放至相应位置即可。  </li>
</ol>
<h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>在电源之间转换时，会用电感用于两种不同电源之间的滤波。  </p>
<p>电源芯片根据所连接芯片的功率（电流）进行选择，同时考虑效率、纹波、封装等因素。</p>
<p>使用LDO(Low Drop Out)电源芯片时，注意Dropout voltage的值，输入一般不能等于输出电压，需更高。</p>
<p>电源芯片对滤波要求较高，datasheet中一般会有layout建议，如滤波电容放在芯片同一面等，按照建议来布局布线。</p>
<p>去耦电容的布置尽量靠近电源管脚，且容值越小的越靠近。过孔最好打在电容的同一侧靠近。</p>
<p>在设计AD/DA/CLK等带模拟信号的电路时，用电源芯片将供电电源隔离，以减少干扰。其他芯片对电源有要求时同理。  </p>
<h4 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h4><p>FPGA会要求大电容（Bulk Capacitor）滤掉低频、陶瓷电容滤中频，个数和数值在User Guide中有推荐，如7系列在UG483-PCB中。位置要求等也会有推荐。  </p>
<p>Xilinx在GU1099中有BGA封装的推荐走线方式。包括宽度、距离、过孔大小等。差分线对走FPGA内部，可以选择neck mode使两线走两via之间，参数参考GU1099，注意适当选择gridless方便内部走线。  </p>
<p>注意单端clk信号连接至FPGA的全局时钟管脚时，要连接至p端，不能连接至n端。</p>
<p>XILINX的FPGA的BANK分为HP/HR两种，所支持的电压、IOSTANDARD（如LVDS/LVDS_25）不同，需要注意。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[入vivado坑之联合modelsim仿真]]></title>
      <url>http://bonewp.github.io.git/2017/02/22/%E5%85%A5vivado%E5%9D%91%E4%B9%8B%E8%81%94%E5%90%88modelsim%E4%BB%BF%E7%9C%9F/</url>
      <content type="html"><![CDATA[<p>最近跟着调PCIE接口，要用Xilinx高端大气上档次的vivado开发环境，然而新入就是坑啊，泪目。</p>
<p>首先背景是，已有在其他电脑上可编译可仿真的工程，在我电脑2016.2版本vivado上可综合通过，但是联合modelsim仿真卡在compiling一步， 于是放弃2016.2版本，装了其他电脑一样的2014.4版本，结果就是漫无止境的填坑过程…</p>
<a id="more"></a>
<p>问题是，联合modelsim进行仿真时，始终会出现错误<code>(vlog-2155) Global declarations are illegal in Verilog 2001 syntax.</code>，根据理解和网上搜索结果，是因为对应的<code>function.vh</code>文件里有<code>function</code>函数，但<code>function</code>和<code>task</code>不能定义在<code>module</code>之外，而调用文件中<code>\`include &quot;function.vh&quot;</code>在<code>module</code>之外，导致出错。若改为vivado自带的仿真器，则会有错误<code>Root Scope Declartion Not Allowed In Verilog 95/2k</code>，应该也是同样的错误。  </p>
<p>神奇的地方在于，按照语法标准来说这确实会出错，但在之前的调试人员电脑上居然能够正常通过，于是找寻各种方法想在不修改源文件的情况下能编译通过。其中搜到的有价值的信息中，有提到过单独定义<code>function</code>和<code>task</code>的<code>.vh</code>后缀文件不加入modelsim仿真编译，但如何才能让其不编译这个文件就是个迷了。</p>
<p>经过两天的苦苦尝试，换了modelsim版本，重装了vivado2016.4，最后还是采用的修改源文件的解决方法，把调用的<code>function</code>全都集中在<code>function.vh</code>文件中，再把<code>\`include &quot;function.vh&quot;</code>命令放在<code>module</code>定义里面，而包括了<code>\`define`命令的`.vh</code>文件则保持放在<code>module</code>定义之外。</p>
<p>最终结论，单独定义<code>function</code>和<code>task</code>的头文件要放在<code>module</code>中调用，而至于为什么之前的电脑上没这么做却通过了，未知…  </p>
<h3 id="仿真卡在compiling的问题"><a href="#仿真卡在compiling的问题" class="headerlink" title="仿真卡在compiling的问题"></a>仿真卡在compiling的问题</h3><p>最开始提到的仿真卡在Executing compiling，我遇到的情况是同时装了vivado2014和vivado2016，但是之前设置的modelsim库是用vivado2014编译的，当我在用2016版本的时候设置ModelSim Compiled Library path是用的14版本的库，导致在16版本中仿真不能正常运行。   </p>
<p>而解决方法当时就是…重新用vivado2016编译个仿真库就行了，真是浪费了我好多时间。<br>注意modelsim.ini中仿真库的路径（但是在vivado中设置了仿真库路径好像就不用改这个了）。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初次使用sway]]></title>
      <url>http://bonewp.github.io.git/2016/10/24/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8sway/</url>
      <content type="html"><![CDATA[<p>前一周准备开题，时间紧脑袋一热没有用ppt，转去用了sway，本来想的目的是不用去调效果、动画，结果不熟悉sway的组织结构，为了达到理想的效果试了很多次，最后演示的时候还因为图片大小问题没演示好。<br>这里把使用经验总结一下，以后再使用好复习。  </p>
<a id="more"></a>
<ol>
<li><p>sway是以图片为重点的，注意sway中的插图尺寸要均衡，不能长宽比过大或过小。<br>像在visio里做的框图若直接源宽高导出，可能会比例失衡，而先放到word里再另存为图片的图，插入的效果就比较好，这是因为图片长宽比按word里的格式保存的；而在visio直接导出时，一定要确定好长宽参数。  </p>
</li>
<li><p>小单位组织为网格时，要按照自己的逻辑去组合，而不是为了达到某种效果而去组合某几个文本/图片。<br>这是由sway全平台自适应的特点决定的，在PC某一分辨率下看组合的网格是某一种样子，而到了另一分辨率或者手机上时，单元layout就会不一样了。所以一定按照自己的逻辑去安排组织结构，我认为这也是sway的设计初衷：<strong>作者仅需要关心文本/图片的逻辑关系，剩下的效果等工作由sway自动完成</strong>。  </p>
</li>
<li><p>垂直滚动的布局比较全能，对各平台的支持都较好。<br>我一开始看第三种适应性布局比较炫，就先试了，然后过了一段时间发现对应当时的文本效果不是很好，然后又转用水平滚动的，结果演示时由于我的图片有些过宽显示不全，演示效果不是很好，最后才发现，我应该使用垂直滚动的布局，对宽图片和文字都能得到比较好的展示，看起来也没有水平滚动那么晕。<br>作为官方采用的默认推荐还是有道理的。  </p>
</li>
</ol>
<p>总结使用就是：选好布局（一般垂直滚动），选好颜色样式，将图片和文字按逻辑整理好即可。<br>总之sway是比较好用的的，云存储，易于分享，上手后使用简单；缺点uwp应用会闪退，还是网页端好用点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[任务书中指标要求的重要性]]></title>
      <url>http://bonewp.github.io.git/2016/10/13/%E4%BB%BB%E5%8A%A1%E4%B9%A6%E4%B8%AD%E6%8C%87%E6%A0%87%E8%A6%81%E6%B1%82%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>这个星期在做硕士论文开题，中间刘老师提到了一句话，让我有种豁然开朗的感觉，大致意思就是：</p>
<blockquote>
<p>论指标论好了，把选型和方案确定，就可以说一个项目做了一半了，剩下的就是结合细节去实现。  </p>
</blockquote>
<p>这让我对现在即将参与和之前负责的项目有了新的认识。自己以前就是个打杂工，老师已经确定下了具体的方案，自己照着去执行就行了，并没有发现有什么问题，还自我感觉良好。<br>但是自己在上一个做的USB体制下的卫星模拟器时，就感觉到了任务指标与设计方案的重要性。自己半路从张老师手中接收过来，从画板子开始。结果板子画完自己写程序写到FPGA管脚分配时，发现7系列的FPGA的HR Bank和HP Bank的区别，特别是管脚电压与AD/DA/CLK芯片的不匹配，进一步又发现了供电电压也给错了…充分暴露了方案设计时的论证不充分，接着就调板子之后再改第二版，结果在第二版调试全部完成之后，发现AD前级缺少模拟AGC，接收功率动态范围根本达不到…  </p>
<a id="more"></a>
<p>从这次经历可以看出来，一方面是使用新的芯片特别是用FPGA时，要对其特性有充分的考察；另一方面就是重点了，要结合任务指标要求，设计好方案及选型，以能达到指标要求。像是第二点，如果在方案设计时就注意到了动态范围的要求，就不会忘记加模拟AGC了。<br>说了这么多话，其实说到底，就是设计方案的重要性以及其难度。就像在组织中领导的重要性，决定好了方向，下级实施者才知道怎么去做，这需要大量的经验基础和专业知识，毕竟下级做着做着做不下去了，可不是实施者的错，是领导决定方向的锅。项目的方案就是领导方向，充分论证了咱们用这些芯片、这种结构能实现目标要求，咱们才接着去干，否则就会发生各种我之前遇到的，做都做完了发现某个地方不对，这时候已经耗费了大量资源了。<br>当然，不会说一点错误都不范，只是在已知范围内尽量地减少错误发生，毕竟未知情况多得去了。<br>最后就是对现在的项目，刘老师提醒了我几次，深入地去认识任务书的要求，为什么要这么要求，我们设计方案时选用这种芯片/结构为什么这么选、能够对应实现要求中的哪个指标，都能搞明白了，也就对这个项目认识了一大半了。<br>所以说呐，作为一只小硕，还是好好地去看任务书和方案吧，只是画画/调调板子、写写程序还是远远不够哒。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FM调制与解调]]></title>
      <url>http://bonewp.github.io.git/2016/09/24/FM%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/</url>
      <content type="html"><![CDATA[<p>之前做的项目中有FM调制解调的算法，然后重新拾起通信原理来复习，惊奇地发现我脑子里记得FM信号表达式一直是错的…简直是再一次对不起学通信这个名号啊（我为什么要说又..）  </p>
<p>首先我知道FM的频率表达式是$f=f_0+f(t)$，然后我理所当然地、头脑短路地认为FM信号表达式为$f(t)=A\cos[2\pi(f_0+f(t))+\theta]$。简直啪啪地打脸…完完全去去地错误，我还天真地以为这是正确的表达式好长一段时间。  </p>
<p><strong>正确的思路</strong> 应该是由频率表达式得出全相位表达式，进而得到余弦信号表达式。<br>首先知道瞬时角频率为$\omega_F(t)=\omega_c+K_F\upsilon(t)$<br>由于调频波在不同时刻的旋转角频率不同，则从$t=0$到$t$时刻所旋转的全相角为瞬时角频率在此时间间隔内的积分，即$\psi_F(t)=\int_0^t\omega_F(t)\,dt=\omega_ct+K_F\int_0^\lambda\upsilon(\lambda)\,d\lambda+\theta_0$<br>那么FM信号的表达式即$\upsilon_F(t)=V_{cm}\cos[\psi_F(t)]=V_{cm}\cos{\omega_ct+K_F\int_0^\lambda\upsilon(\lambda)\,d\lambda+\theta_0}$  </p>
<a id="more"></a>
<p>相比较而言PM的表达式就只是少了一个积分号$\upsilon_P(t)=V_{cm}\cos{\omega_ct+K_P\upsilon(t)+\theta_0}$<br>扩展一下，接收机中可以统一使用PM调制解调，而当要使用FM时，调制模块先对输入信号作积分，解调模块对输出信号作微分即可实现FM。  </p>
<p>而除了刚才提到的PM解调后微分的方法，FM解调还可使用鉴频器的方法，先偷个懒截图上原理。待后续填坑。<br><img src="/2016/09/24/FM调制与解调/FM解调_鉴频.png" alt="FM解调_鉴频.png" title=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[超外差的概念]]></title>
      <url>http://bonewp.github.io.git/2016/09/24/%E8%B6%85%E5%A4%96%E5%B7%AE%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>本科时学习通信原理就接触了超外差式(superheterodyne)接收机，也知道超外差式接收机的原理和框图，现在做了一些相关项目对此类功能也是熟悉了很多，但就是从来没去关注过为什么叫做超外差这么个奇怪的名字。<br>这两天赶硕士论文开题，补《雷达系统及其信息处理》，在雷达接收机章节中又看到这个词，才重新细细思考起这个词儿，然后突然觉得自己简直对不起学通信这个名号…连超外差这个词过了几年才明白。  </p>
<p>首先从这个词的起源说起，超外差来源于外差(heterodyne)，引用百度百科上的说法  </p>
<blockquote>
<p> heterodyne（外差原理）来自于希腊语的词根hetero（不同的）和dyn（功率）。<br>外差法的英文原意应该是 “不同频率信号作为驱动力的方法”, 用汉语可凝练成 “异频驱使法”, 再进一步, 就变成 “外差法” 了. 这个从外差法专利文档中也可以得到印证, 其在最后的保护范围声明中, 斐德森一口气开列了 9种情况, 核心内容都是”用两个以及两个以上频率的信号相作用产生新的频率的方法”。  </p>
</blockquote>
<p>也就是说本质是利用两个频率混频之后的结果得到所用信号的频率。一个词总结就是<strong>频谱搬移</strong>。<br>尼玛原来频移的技术是这么引入进来的，我现在做的硬件很多都在搞上/下变频、升/降采样，都跟着玩意儿有关，搞了这么久才知道精髓原来就是外差…  </p>
<a id="more"></a>
<p>再回到超外差，从名字可看出，超外差就是由外差发展而来的，引用维基百科的说法  </p>
<blockquote>
<p>超外差接收机是一种利用超外差原理的无线电接收机，1918年由美国无线电工程师埃德温·霍华德·阿姆斯特朗发明。超外差原理是一种利用机器内一个可变的振荡器产生的电波和外来信号混合以产生固定频率的中频信号。  </p>
</blockquote>
<p>也就是超外差多了一个从射频到中频的过程，这样接收处理就相对容易了，涉及到中频滤波等等。<br>其框图、优点之类的不再赘述了，百科中都有，总之超外差这个概念弄明白了，那么接收机的原理基本上也就有个数了。</p>
<p>reference:<br><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%A4%96%E5%B7%AE%E6%94%B6%E9%9F%B3%E6%9C%BA" target="_blank" rel="external">超外差收音机-维基百科</a><br><a href="http://baike.baidu.com/view/1029112.htm#reference-[1]-1029112-wrap" target="_blank" rel="external">超外差-百度百科</a><br><a href="http://baike.baidu.com/subview/5032345/5035457.htm" target="_blank" rel="external">外差原理</a>  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[usb体制及测控技术相关]]></title>
      <url>http://bonewp.github.io.git/2016/08/25/usb%E4%BD%93%E5%88%B6%E5%8F%8A%E6%B5%8B%E6%8E%A7%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>最近做的项目是基于USB体制下的相关算法，于是找了些资料把这个体制给了解了一下，在此做一下总结。</p>
<h3 id="USB体制来源"><a href="#USB体制来源" class="headerlink" title="USB体制来源"></a>USB体制来源</h3><p>USB(Unified S Band)全称统一S波段测控体制，最早是由美方提出并在1966年用于“阿波罗”登月计划，为解决原测控网中多种频段设备的复杂、电磁兼容性差、作用距离不够等问题缺陷，将跟踪测轨、遥控、遥测综合为一体，为测控技术发展史上的一个里程碑<sup><a href="#1">[1]</a></sup>。</p>
<blockquote>
<p>到1979年，世界无线电管理会议决定以S波段作为空间业务频段以后,更促进了USB的进一步发展。到了80年代，USB又被纳入国际空间数据系统咨询委员会(CCSDS)标准，并已为世界上多数国家共同接受，为有利于开展国际合作，世界上许多国家都按此建造统一S波段系统，使USB得到了进一步的推广和发展。世界上各航天国家如：中、美、前苏联、法、日、德、巴、印以及国际航天组织（如欧空局、阿拉伯卫星通信组织，亚州卫星通信组织）都相继建立了自己的USB和UCB(统一C波段)测控系统，使统一载波测控系统如雨后春笋般地出现在地球上。</p>
</blockquote>
<p>在找到的一篇<a href="http://public.ccsds.org/" target="_blank" rel="external">ccsds</a>介绍中提到了我国最早应用USB体制的卫星<sup><a href="#2">[2]</a></sup>：</p>
<blockquote>
<p>从九十年代开始我国的航天测控系统开始采用统一S波段测控体制（USB），在射频与调制的物理层采用了CCSDS标准，与此同时我国也在链路层以上的高层协议上研究采用CCSDS标准。1999年5月10日发射的实践五号卫星，在我国是第一个采用 USB测控体制的航天器，也是第一个采用CCSDS-AOS高级在轨系统标准的航天器。此后我国与欧空局合作的空间科学探测项目“双星计划”的两颗卫星“探测一号”和“探测二号”卫星的数传数据不但完全采用CCSDS-AOS高级在轨系统标准，而且向CCSDS组织正式申请了飞行器识别符。</p>
</blockquote>
<h3 id="USB基本原理"><a href="#USB基本原理" class="headerlink" title="USB基本原理"></a>USB基本原理</h3><p>测控通信系统是卫星系统的五大系统之一、载人航天系统的七大系统之一，完成对飞船的测轨、遥控、遥测、话音通信和电视传输等重要作用<sup><a href="#3">[3]</a></sup>。<br>对于遥测、遥控、测速等概念可参考文献<a href="#4">[4]</a>。</p>
<blockquote>
<p>国际上对于航天测控定义为：“Tracking, Telemetry&amp;Command”(缩写TT&amp;C)，中文通常称“跟踪，遥测及遥控”。  </p>
</blockquote>
<a id="more"></a>
<p>相对于以前不同功能采用不同载波的方式，USB体制如其名字所体现的是“统一载波”：将遥测、遥控、跟踪信号先用bpsk调制在多个副载波上，再用PM调制在一个载波上，进而搬移至S波段发射。在接收上与调相对应的锁相技术是其重要技术之一。<br>文献<a href="#3">[3]</a>中总结了载人航天USB测控系统的综合化、高可靠性、高测轨精度、抗组合干扰、数字化、大动态控制、目标快速捕获等关键技术。其中对综合化中的“五合一”信号设计，我觉得可以帮助理解USB体制的特点：</p>
<blockquote>
<p>“五合一”信号设计<br>(1) 频分制的下行双载波: 一个用于测控(TT&amp;C)，另一个用于数传(DDT)。TT&amp;C 和 DDT 可同时存在。<br>(2) 频分制的 TT&amp;C 副载波： 下行为遥测和测距音组三种副载波，上行为遥控、话音和测距音组等四种副载波， TT&amp;C 载波采用调相/调相(PM/PM)调制。<br>(3) 时分制的 DDT 载波: 完全用作数据传输，采用 PCM/QPSK 调制。以2兆比特/秒码速传输下行话音、电视、遥测、GPS、交会雷达和科学实验数据等多路信息。<br>(4) FM 遥测载波： 航天器可用另一个载波发射高码速的遥测信号，调制方式为 PCM-FM 。 TT&amp;C 和 FM 可同时存在，为频分工作。</p>
</blockquote>
<h3 id="相关发展及感想"><a href="#相关发展及感想" class="headerlink" title="相关发展及感想"></a>相关发展及感想</h3><p>虽然吹了USB体制这么多，目前也确实是相对成熟的一套体制，，不过其一些缺点不足我觉得也是有的，如设备重复度高，这是频分复用的特点造成的；保密的问题；多目标测控时副载波之间的干扰等。<br>为了往未来天基测控进而深空测控的方向发展，其使用的各种技术都还会提升，如使用扩频测控，频带往更高的频段发展等等。当然这些都是后话了，作为一个小硕我还是老老实实地去想算法写代码吧 ( &gt;﹏&lt;。)～</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><span id="1"> </span> 刘嘉兴. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=9&amp;CurRec=1&amp;recid=&amp;filename=DATE902.000&amp;dbname=CJFD9899&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;uid=WEEvREcwSlJHSldTTGJhYlRaSXVoREFFTWF3MEF2VFBwN1NmS3NlQ3RtWU8=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDc0NDFTemZhN3E0SE0vTXI0OHFGNTRPZmdnNXpoQVU0amg0T1g2VHJIMDNlYk9TUmJLZFl1UnVGU2puVVE9PUk=" target="_blank" rel="external">航天测控技术的过去、现在和未来</a>、现在和未来[J]. 电讯技术,1999,02:3+5-10.</li>
<li><span id="2"> </span> <a href="www.nssc.cas.cn/xwzx/kydt/201307/W020130717344100734922.pdf">CSDS 概述 - 国家空间科学中心 - 中国科学院</a></li>
<li><span id="3"> </span> 刘嘉兴. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=0&amp;CurRec=1&amp;recid=&amp;filename=YHXB200506013&amp;dbname=CJFD2005&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;v=MzEzMjJYVGJMRzRIdFRNcVk5RVo0UjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSTHlmYitScUZDdmdVYnZQUEM=" target="_blank" rel="external">载人航天USB测控系统及其关键技术</a>[J]. 宇航学报,2005,06:743-747.</li>
<li><span id="3"> </span> 饶启龙. <a href="http://www.cnki.net/KCMS/detail/detail.aspx?QueryID=12&amp;CurRec=1&amp;recid=&amp;filename=OXXT201103017&amp;dbname=CJFD2011&amp;dbcode=CJFQ&amp;pr=&amp;urlid=&amp;yx=&amp;uid=WEEvREcwSlJHSldTTGJhYlRaSXVoREFFTWF3MEF2VFBwN1NmS3NlQ3RtWU8=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MjYyOTk4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUkx5ZmIrUnFGQ25oVjdyQktqWFRlckc0SDlETXJJOUVZNFI=" target="_blank" rel="external">航天测控技术及其发展方向</a>[J]. 信息通信技术,2011,03:77-83.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给marika感动得不要不要的]]></title>
      <url>http://bonewp.github.io.git/2016/08/20/%E7%BB%99marika%E6%84%9F%E5%8A%A8%E5%BE%97%E4%B8%8D%E8%A6%81%E4%B8%8D%E8%A6%81%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>之前伪恋看了一集就弃掉了，最近重新拾起来觉得这n角恋还挺好玩的，补了动画补漫画，结果进了marika线简直停不下来啊！我觉得marika简直是这里面塑造的最成功的角色了，人妻属性点满、逗逼属性点满，努力有觉悟。啊！~~~老夫的少女心…⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄…. (੭ु≧▽≦)੭ु</p>
<a id="more"></a>
<p>刚看动画的时候还只是觉得这孩子比较逗加上满满的套路就是了，到了逼婚线把背景都给交代清楚了才知道这尼玛绝对是后宫里最努力的人了啊。到逼婚这儿的时候简直感动得不要不要的 滚来滚去……~(～o￣▽￣)～o 。。。滚来滚去……o～(＿△＿o～) ~。。  </p>
<img src="/2016/08/20/给marika感动得不要不要的/marika.png" alt="marika.png" title="">  
<p>祝marika能找到自己的幸福，嗯！(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)</p>
<img src="/2016/08/20/给marika感动得不要不要的/marika.jpg" alt="marika.jpg" title="">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const限定符相关]]></title>
      <url>http://bonewp.github.io.git/2016/08/18/const%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>阅读const限定符一节的时候很是绕了点，发现这里很容易混淆，所以记录一下。</p>
<p>在需要定义变量的值不能被改变的时候，使用const加以限定，如<code>const int buffSize = 512;</code>这里是指变量本身是常量。</p>
<p>而在定义引用和指针的时候，注意是指<strong>引用或指针是指向常量的引用或指针</strong>，如<code>const int *p;</code>，这里指针p是<strong>指向常量的指针(pointer to const)</strong>， p指向的值必须是一个const类型，而p本身的值（即所存储的地址）则可以改变。这里一定要明确的概念就是<strong>指向常量的引用/指针不能用于改变其绑定/所指对象的值</strong>。</p>
<p>由于引用在初始化后不能再更改绑定对象，不用多说。而要让指针本身是常量的话，需要使用<code>*const</code>来定义<strong>常量指针(const pointer)</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;  <span class="comment">//p本身的值不能再改变，始终指向i</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> pip = &amp;pi; <span class="comment">//pip是一个指向常量的常量指针</span></div></pre></td></tr></table></figure></p>
<p>由此可见，指针本身是常量和指向的对象是常量为两个独立问题。</p>
<blockquote>
<p>用名词<strong>顶层const(top-level const)</strong>表示指针本身为 常量，而用名词<strong>底层const(low-level const)</strong>表示指针所指的对象为一个常量。  </p>
</blockquote>
<p>顶层const可用于基本类型在内的任意对像，而底层const则与指针和引用等复合类型的基本类型部分有关。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[术语：何为对象]]></title>
      <url>http://bonewp.github.io.git/2016/08/17/%E6%9C%AF%E8%AF%AD%EF%BC%9A%E4%BD%95%E4%B8%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>最近腾出点时间复习C++，准备把C++ Primer好好看一遍。  </p>
<p>在<code>P39</code>上看到一个有趣的地方，什么是<strong>术语</strong>？书上给的解释是:  </p>
<blockquote>
<p>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p>
</blockquote>
<p>以前接触对象这个概念，总是基于面向对象之类的东西来说，一直感觉比较抽象。而这个从偏硬件的角度的解释，让我有一种豁然开朗的感觉，特别是在现在用FPGA用得多了之后。  </p>
<p>就像对FPGA代码最终要映射到FF、LUT等单元，对软件而言高级语言最终是要对应CPU对内存上的一段数据进行操作，这样刚才<strong>对象</strong>的解释也就能明白了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[verilog中的加法]]></title>
      <url>http://bonewp.github.io.git/2016/08/11/verilog%E4%B8%AD%E7%9A%84%E5%8A%A0%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>这两天调一个项目的时候涉及到了符号数的加法和限幅，调了好久才发现这里面的坑。。瞬间觉得自己基础有待提高啊</p>
<h3 id="符号数的加法"><a href="#符号数的加法" class="headerlink" title="符号数的加法"></a>符号数的加法</h3><p>用补码来表示符号数，对两个符号数相加可以直接加法赋值，如下列代码，这是由补码的特性决定的，非常方便。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_1;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_2;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] add_ans;</div><div class="line"></div><div class="line">assign add_ans = sig_1 + sig_2;</div></pre></td></tr></table></figure></p>
<h3 id="加法溢出的处理"><a href="#加法溢出的处理" class="headerlink" title="加法溢出的处理"></a>加法溢出的处理</h3><p>然而固定位数的加法会出现溢出的问题，要为结果考虑进位，因此为结果多添加一位。此时一定要注意！</p>
<p><strong>符号数加法要进行符号位扩展！！</strong></p>
<p>当时没有注意到这个，死活不知道为什么结果的进位消失了…示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_1;</div><div class="line">wire [<span class="number">31</span>:<span class="number">0</span>] sig_2;</div><div class="line">wire [<span class="number">32</span>:<span class="number">0</span>] add_ans;</div><div class="line"></div><div class="line">assign add_ans = &#123;sig_1[<span class="number">31</span>], sig_1&#125; + &#123;sig_2[<span class="number">31</span>], sig_2&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="加法溢出限幅处理"><a href="#加法溢出限幅处理" class="headerlink" title="加法溢出限幅处理"></a>加法溢出限幅处理</h3><p>如果加法结果溢出了，但是要传至的信号位数是固定的，那么就需要限幅。</p>
<p>相对来说这个也很简单，这里占个坑，以后有需要再来填。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[写markdown时用到的特殊用法]]></title>
      <url>http://bonewp.github.io.git/2016/08/09/%E5%86%99markdown%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>我在用Markdown写东西的时候，有时候用到了一些奇奇怪怪的用法，这里记录下来以便之后查阅。</p>
<h3 id="makedown通用语法相关"><a href="#makedown通用语法相关" class="headerlink" title="makedown通用语法相关"></a>makedown通用语法相关</h3><h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a><span id="sup/sub">上下标</span></h4><p>将需要修改为上下标的文字用html标签包裹即可。如下：<br>上标：<code>&lt;sup&gt; sup_text &lt;/sup&gt;</code><br>下标：<code>&lt;sub&gt; sup_text &lt;/sub&gt;</code></p>
<h4 id="文章内跳转"><a href="#文章内跳转" class="headerlink" title="文章内跳转"></a>文章内跳转</h4><p>将需要跳转至的地方加上html的id属性，形如：<code>&lt;span id=&quot;where_jump_to&quot;&gt; text &lt;/span&gt;</code><br>再在需要设置跳转的地方使用Markdown的链接语法，形如：<code>[text](#where_jump_to)</code></p>
<p>这里测试一下跳转至<a href="#sup/sub">上下标</a>。</p>
<a id="more"></a>
<h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>在断首加入<code>&amp;ensp;</code>输入一个空格；加入<code>&amp;emsp;</code>输入两个空格。</p>
<blockquote>
<p>&emsp;效果演示<br>效果演示  </p>
</blockquote>
<h3 id="框架使用相关"><a href="#框架使用相关" class="headerlink" title="框架使用相关"></a>框架使用相关</h3><h4 id="hexo相关"><a href="#hexo相关" class="headerlink" title="hexo相关"></a>hexo相关</h4><h5 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h5><p>我没有把图片存储到云盘上的习惯。。（好像暴露了什么），查阅到使用的hexo框架支持资源文件夹可以便捷的管理。</p>
<p>通过在站点配置文件<code>config.yml</code>中的<code>post_asset_folder</code>选项设为<code>true</code>后，可以将图片放在与文章同名的文件夹内，然后使用相对路径应用的标签插件来引用图片等资源，相较于常规的markdown语法<code>![](/image.jpg)</code>，可使图片在主页和存档页显示正常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure>
<h5 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h5><p>在文章中使用<code>&lt;!-- more --&gt;</code>手动进行截断，Hexo 提供的方式。</p>
<h4 id="Next相关"><a href="#Next相关" class="headerlink" title="Next相关"></a>Next相关</h4><p>..</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vivado IO Constraint]]></title>
      <url>http://bonewp.github.io.git/2016/07/13/Vivado-IO-Constrain/</url>
      <content type="html"><![CDATA[<h2 id="IO-delay"><a href="#IO-delay" class="headerlink" title="IO delay"></a>IO delay</h2><h3 id="Input-delay"><a href="#Input-delay" class="headerlink" title="Input delay"></a>Input delay</h3><hr>
<p>数据相对于上升沿往后的延迟。<br><img src="/2016/07/13/Vivado-IO-Constrain/inputDelay_1.png" alt="inputDelay_1" title="inputDelay_1"><br><img src="/2016/07/13/Vivado-IO-Constrain/inputDelay_2.png" alt="inputDelay_2" title="inputDelay_2"><br>Example code:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create_clock -name sysClk -period <span class="number">10</span> [get_ports CLK0]</div><div class="line">set_input_delay -<span class="keyword">clock</span> sysClk -max <span class="number">4</span> [get_ports DIN]</div><div class="line">set_input_delay -<span class="keyword">clock</span> sysClk -min <span class="number">1</span> [get_ports DIN]</div></pre></td></tr></table></figure>
<p>若不考虑板级延迟，那就可根据前级芯片的建立/保持时间来推算此MAX/MIN的值。</p>
<a id="more"></a>
<h3 id="Output-delay"><a href="#Output-delay" class="headerlink" title="Output delay"></a>Output delay</h3><hr>
<p>数据相对于上升沿往前的延迟。即原点在目标时钟的上升沿，正半轴朝往前面的时间。<br><img src="/2016/07/13/Vivado-IO-Constrain/outputDelay_1.png" alt="outputDelay_1" title="outputDelay_1"><br>如果设定trce_dly都等于0的话（即板级延迟忽略），那么：</p>
<blockquote>
<p>The set_output_delay -max should be the setup requirement of the external device; The set_output_delay -min should be the negative of the hold requirement.</p>
</blockquote>
<p>Example code:</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set_output_delay -<span class="keyword">clock</span> &lt;<span class="keyword">clock</span>&gt; <span class="number">0.6</span> [get_ports NWAIT]</div><div class="line">set_output_delay -<span class="keyword">clock</span> &lt;<span class="keyword">clock</span>&gt; <span class="number">-3.2</span> -min [get_ports NWAIT]</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://bonewp.github.io.git/2016/07/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
